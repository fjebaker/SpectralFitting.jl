export AbstractSpectralModel,
    AbstractSpectralModelKind,
    Multiplicative,
    Additive,
    Convolutional,
    modelkind,
    AbstractSpectralModelImplementation,
    XSPECImplementation,
    JuliaImplementation,
    implementation,
    AbstractSpectralModelClosureType,
    WithClosures,
    WithoutClosures,
    closurekind,
    has_closure_params,
    #get_param_symbols,
    #get_param_types,
    #model_base_name,
    #get_closure_param_fields,
    get_param_symbols,
    get_param,
    get_param_count,
    get_all_model_params,
    get_all_model_params_by_value,
    get_param_symbol_pairs,
    invokemodel,
    invokemodel!,
    flux_count


# models
"""
    abstract type AbstractSpectralModel

Supertype of all spectral models. Sub-types must implement the following interface
- [`modelkind`](@ref)
- [`SpectralFitting.invoke!`](@ref)
"""
abstract type AbstractSpectralModel end
numbertype(::AbstractSpectralModel) = Sys.WORD_SIZE == 64 ? Float64 : Float32

# traits
"""
    abstract type AbstractSpectralModelKind

Abstract type of all model kinds.
"""
abstract type AbstractSpectralModelKind end
"""
    Additive <: AbstractSpectralModelKind
    Additive()

Additive models are effectively the sources of photons, and are the principle building blocks
of composite models.

!!! note
    Defining custom additive models requires special care. See [Defining new models](@ref).
"""
struct Additive <: AbstractSpectralModelKind end
"""
    Multiplicative <: AbstractSpectralModelKind
    Multiplicative()

Multiplicative models act on [`Additive`](@ref) models, by element-wise
multiplying the flux in each energy bin of the additive model by a different factor.
"""
struct Multiplicative <: AbstractSpectralModelKind end
"""
    Convolutional <: AbstractSpectralModelKind
    Convolutional()

Convolutional models act on the flux generated by [`Additive`](@ref) models, similar to
[`Multiplicative`](@ref) models, however may convolve kernels through the flux also.
"""
struct Convolutional <: AbstractSpectralModelKind end

"""
    modelkind(M::Type{<:AbstractSpectralModel})

Return the kind of model given by `M`: either `Additive`, `Multiplicative`, or `Convolutional`.
"""
modelkind(m::Type{<:AbstractSpectralModel}) = error("Not defined for $(typeof(m)).")

abstract type AbstractSpectralModelImplementation end
struct XSPECImplementation <: AbstractSpectralModelImplementation end
struct JuliaImplementation <: AbstractSpectralModelImplementation end

implementation(::Type{<:AbstractSpectralModel}) = JuliaImplementation()

abstract type AbstractSpectralModelClosureType end
struct WithClosures <: AbstractSpectralModelClosureType end
struct WithoutClosures <: AbstractSpectralModelClosureType end

closurekind(::Type{<:AbstractSpectralModel}) = WithoutClosures()

has_closure_params(::WithClosures) = true
has_closure_params(::WithoutClosures) = false
has_closure_params(M::Type{<:AbstractSpectralModel}) = has_closure_params(closurekind(M))
has_closure_params(::M) where {M<:AbstractSpectralModel} = has_closure_params(M)

# implementation interface
# never to be called directly
# favour `invokemodel!` instead
"""
    SpectralFitting.invoke!(flux, energy, M::Type{<:AbstractSpectralModel}, params...)

Used to define the behaviour of models. Should calculate flux of the model and write in-place
into `flux`.

!!! note
    This function should not be called directly. Use [`invokemodel`](@ref) instead.

Parameters are passed in in-order as defined in the model structure. For example
```julia
struct MyModel{F1,F2,F3,...} <: AbstractSpectralModel
    p1::F1
    p2::F2
    p3::F3
    # ...
end
```
would have the arguments passed to `invoke!` as
```julia
function SpectralFitting.invoke!(flux, energy, ::Type{<:MyModel}, p1, p2, p3, ...)
    # ...
end
```

The only exception to this are [`Additive`](@ref) models, where the normalisation parameter
`K` is not passed to `invoke!`.
"""
invoke!(flux, energy, ::Type{M}, params...) where {M<:AbstractSpectralModel} =
    error("Not defined for $(M).")

# optional interface
get_param_symbols(M::Type{<:AbstractSpectralModel}) = fieldnames(M)
get_param_types(M::Type{<:AbstractSpectralModel}) = M.types

model_base_name(M::Type{<:AbstractSpectralModel}) = Base.typename(M).name

# only needed for WithClosures()
get_closure_param_fields(::Type{<:AbstractSpectralModel}) = ()

# minimal param accessors
get_param_types(::M) where {M<:AbstractSpectralModel} = get_param_types(M)
get_param_symbols(::M) where {M<:AbstractSpectralModel} = get_param_symbols(M)
get_param(m::AbstractSpectralModel, s::Symbol) = getproperty(m, s)

# emergent param accessors
get_param_count(M::Type{<:AbstractSpectralModel}) = length(get_param_types(M))

get_all_model_params(m::AbstractSpectralModel) where {M} =
    (get_param(m, p) for p in get_param_symbols(m))
get_all_model_params_by_value(m::AbstractSpectralModel) =
    (get_value(i) for i in get_all_model_params(m))
# todo: make this a proper iterator? also better name
get_param_symbol_pairs(m::M) where {M<:AbstractSpectralModel} =
    (p => get_param(m, p) for p in get_param_symbols(m))

# invokation wrappers
function invokemodel(e, m::AbstractSpectralModel)
    fluxes = make_fluxes(e, flux_count(m))
    invokemodel!(fluxes, e, m)
    first(fluxes)
end
function invokemodel(e, m::AbstractSpectralModel, free_params)
    if eltype(free_params) <: Number
        # for compatability with AD
        fluxes = make_fluxes(e, flux_count(m), eltype(free_params))
        invokemodel!(fluxes, e, m, free_params)
    else
        p0 = get_value.(free_params)
        invokemodel!(fluxes, e, m, p0)
    end
    first(fluxes)
end

function invokemodel!(f, e, m::AbstractSpectralModel, free_params)
    frozen_params = get_value.(get_frozen_model_params(m))
    invokemodel!(f, e, m, free_params, frozen_params)
end
function invokemodel!(f, e, model::AbstractSpectralModel, free_params, frozen_params)
    generated_model_call!(f, e, model, free_params, frozen_params)
end

invokemodel!(f, e, m::M) where {M<:AbstractSpectralModel} =
    invokemodel!(f, e, M, get_all_model_params_by_value(m)...)

# mainly used in function generation for single models
invokemodel!(f, e, ::Type{M}, p...) where {M<:AbstractSpectralModel} =
    invokemodel!(f, e, modelkind(M), M, p...)

# implementations
@fastmath function invokemodel!(
    flux,
    energy,
    ::Additive,
    M::Type{<:AbstractSpectralModel},
    K,
    p...,
)
    invoke!(flux, energy, M, p...)
    flux ./= K
end
@fastmath function invokemodel!(
    flux,
    energy,
    ::AbstractSpectralModelKind,
    M::Type{<:AbstractSpectralModel},
    p...,
)
    invoke!(flux, energy, M, p...)
    flux
end

# bindings to generated functions

flux_count(model::AbstractSpectralModel) = generated_maximum_flux_count(model)

# printing

function modelinfo(m::M) where {M<:AbstractSpectralModel}
    params = join([get_value(p) for p in get_all_model_params(m)], ", ")
    "$(model_base_name(M))[$(params)]"
end

function Base.show(io::IO, ::MIME"text/plain", m::M) where {M<:AbstractSpectralModel}
    params = [String(s) => p for (s, p) in get_param_symbol_pairs(m)]
    print(io, "$(model_base_name(M))\n")

    pad = maximum(i -> length(first(i)), params) + 1

    for (s, val) in params
        print(io, "   $(rpad(s, pad)) => ")
        println(io, val)
    end
end
