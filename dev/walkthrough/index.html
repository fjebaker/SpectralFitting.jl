<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Walkthrough · SpectralFitting.jl</title><meta name="title" content="Walkthrough · SpectralFitting.jl"/><meta property="og:title" content="Walkthrough · SpectralFitting.jl"/><meta property="twitter:title" content="Walkthrough · SpectralFitting.jl"/><meta name="description" content="Documentation for SpectralFitting.jl."/><meta property="og:description" content="Documentation for SpectralFitting.jl."/><meta property="twitter:description" content="Documentation for SpectralFitting.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SpectralFitting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralFitting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Walkthrough</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#MCMC"><span>MCMC</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examples/">Diverse examples</a></li><li><a class="tocitem" href="../examples/sherpa-example/">A quick guide</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../models/using-models/">Using models</a></li><li><a class="tocitem" href="../models/models/">Model index</a></li><li><a class="tocitem" href="../models/composite-models/">Composite models</a></li><li><a class="tocitem" href="../models/surrogate-models/">Surrogate models</a></li></ul></li><li><span class="tocitem">Datasets</span><ul><li><a class="tocitem" href="../datasets/datasets/">Using datasets</a></li><li><a class="tocitem" href="../datasets/mission-support/">Mission support</a></li></ul></li><li><a class="tocitem" href="../why-and-how/">Why &amp; How</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Walkthrough</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Walkthrough</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fjebaker/SpectralFitting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fjebaker/SpectralFitting.jl/blob/main/docs/src/walkthrough.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Walkthrough"><a class="docs-heading-anchor" href="#Walkthrough">Walkthrough</a><a id="Walkthrough-1"></a><a class="docs-heading-anchor-permalink" href="#Walkthrough" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This walk through has not been fleshed out with the relevant astrophysical content yet (for example, whether a fit is good, what the different parameters mean, etc.), and so assumes some familarity with spectral fitting in general.</p><p>It is also not yet complete, nor a faithful illustration of everything SpectralFitting.jl can do. It serves to illustrate similarities and differences in syntax between SpectralFitting.jl and XSPEC.</p></div></div><p>This example walkthrough is the SpectralFitting.jl equivalent of the <a href="https://heasarc.gsfc.nasa.gov/docs/xanadu/xspec/manual/node35.html">Walk through XSPEC</a> from the XSPEC manual. We will use the same dataset, available for download from this <a href="https://heasarc.gsfc.nasa.gov/docs/xanadu/xspec/walkthrough.tar.gz">link to the data files</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The first thing we want to do is load our datasets. Unlike in XSPEC, we have no requirement of being in the same directory as the data, or even that all of the response, ancillary, and spectral files be in the same place. For simplicity, we&#39;ll assume they are:</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Be sure to set <code>DATADIR</code> pointing to the directory where you keep the walkthrough data.</p></div></div><pre><code class="language-julia hljs">using SpectralFitting, Plots

DATADIR = &quot;...&quot;
spec1_path = joinpath(DATADIR, &quot;s54405.pha&quot;)
data = OGIPDataset(spec1_path)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ OGIPDataset:
│   . Object              : 1E 1048-5937
│   . Observation ID      : [no observation id]
│   . Exposure ID         : [no exposure id]
│ <span class="sgr36">SpectralData</span> with <span class="sgr36">125</span> active channels:
│   . Chn. E (min/max)    : (0.69357, 70.563)
│   . Masked channels     : 0 / 125
│   . Model domain size   : 129
│   . Domain (min/max)    : (0.44347, 36.632)
│ <span class="sgr36">Primary Spectrum:</span>
│  Spectrum: EXOSAT[ME]
│   Units                 : counts s^-1
│   . Exposure time       : 23580.0
│   . Channels            : 125
│   . Data (min/max)      : (-0.028499, 0.30515)
│   . Grouped             : yes
│   . Bad channels        : yes (40)
│ <span class="sgr36">Response:</span>
│  Response Matrix <span class="sgr36">(125 x 128)</span> channels:
│   . Chn. E (min/max)    : (0.69357, 70.563)
│   . Domain E (min/max)  : (0.44347, 36.632)
│ <span class="sgr90">Background: nothing</span>
│ <span class="sgr90">Ancillary: nothing</span>
└ </code></pre><p>This will print a little card about our data, which shows us what else SpectralFitting.jl loaded. We can see the <code>Primary Spectrum</code>, the <code>Response</code>, but that the <code>Background</code> and <code>Ancillary</code> response files are missing. That&#39;s to be expected, since we don&#39;t have those files in the dataset. </p><p>We can check what paths it used by looking at</p><pre><code class="language-julia hljs">data.paths</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SpectralFilePaths:
  . Spectrum       : /home/runner/work/SpectralFitting.jl/SpectralFitting.jl/docs/build/../../ex-datadir/s54405.pha
  . Response       : /home/runner/work/SpectralFitting.jl/SpectralFitting.jl/docs/build/../../ex-datadir/s54405.rsp
  . Background     : nothing
  . Ancillary      : nothing
</code></pre><p>We can load and alter any part of a dataset as we do our fitting. For example, if you have multiple different ancillary files at hand, switching them between fits is a one-liner.</p><p>To visualize our data, we can use some of the <a href="https://docs.juliaplots.org/latest/">Plots.jl</a> recipes included in SpectralFitting.jl:</p><pre><code class="language-julia hljs">plot(data, xlims = (0.5, 70), xscale = :log10)</code></pre><img src="8272e33d.svg" alt="Example block output"/><p>Note that the units are currently not divided by the energy bin widths. We can either do that manually, or use the <a href="@ref"><code>normalize!</code></a> to convert whatever units the data is currently in to the defacto standard <code>counts s⁻¹ keV⁻¹</code> for fitting. Whilst we&#39;re at it, we see in the model card that there are 40 <a href="https://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/spectra/ogip_92_007.pdf">bad quality bins</a> still present in our data. We can drop those as well, and plot the data on log-log axes:</p><pre><code class="language-julia hljs">normalize!(data)
drop_bad_channels!(data)
plot(data, ylims = (0.001, 2.0), yscale = :log10, xscale = :log10)</code></pre><img src="bd4817c2.svg" alt="Example block output"/><p>Note that when there are no negative axes, the scale defaults to log on the plot unless otherwise specified.</p><p>Next we want to specify a model to fit to this data. Models that are prefixed with <code>XS_</code> are models that are linked from the XSPEC model library, provided via <a href="https://github.com/astro-group-bristol/LibXSPEC_jll.jl">LibXSPEC_jll</a>. For a full list of the models, see <a href="@ref">Models library</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is advised to <strong>use the Julia implemented models</strong>. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see <a href="../why-and-how/#Why-and-how">Why &amp; how</a>.</p></div></div><p>We will start by fitting a photoelectric absorption model that acts on a power law model:</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To see information about a model, use the <code>?</code> in the Julia REPL:</p><pre><code class="language-julia hljs">julia&gt; ?PowerLaw
XS_PowerLaw(K, a)

    •  K: Normalisation.

    •  a: Photon index.

Example
≡≡≡≡≡≡≡
...</code></pre></div></div><pre><code class="language-julia hljs">model = PhotoelectricAbsorption() * PowerLaw()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 model components:
│ <span class="sgr36">     m1 * a1</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;  2 ± 0.2  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><p>If we want to specify paramters of our model at instantiation, we can do that with</p><pre><code class="language-julia hljs">model = PhotoelectricAbsorption() * PowerLaw(a = FitParam(3.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 model components:
│ <span class="sgr36">     m1 * a1</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;  3 ± 0.3  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><p>SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a <a href="@ref"><code>FittingProblem</code></a>:</p><pre><code class="language-julia hljs">prob = FittingProblem(model =&gt; data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingProblem:
│   Models:
│     . CompositeModel[<span class="sgr36">PhotoelectricAbsorption * PowerLaw</span>]
│   Data:
│     . OGIPDataset[[no observation id]]
└ </code></pre><p>SpectralFitting.jl makes a huge wealth of optimizers availble from <a href="https://github.com/SciML/Optimization.jl">Optimizations.jl</a>, and others from further afield. For consistency with XSPEC, we&#39;ll use here a delayed-gratification least-squares algorithm from <a href="https://github.com/JuliaNLSolvers/LsqFit.jl">LsqFit.jl</a>:</p><pre><code class="language-julia hljs">result = fit(prob, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[<span class="sgr36">PhotoelectricAbsorption * PowerLaw</span>]
│   . u     : [22.181, 2.2488, 0.56637]
│   . σᵤ    : [4.3720, 0.12638, 0.27433]
│   . χ²    : 108.94 
└ </code></pre><p>Here we can see the parameter vector, the estimated error on each parameter, and the measure of the fit statistic (here chi squared). We can overplot our result on our data easily:</p><pre><code class="language-julia hljs">plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10
)
plot!(data, result)</code></pre><img src="95bc83ed.svg" alt="Example block output"/><p>Our model does not account for the high energy range well. We can ignore that range for now, and select everything from 0 to 15 keV and refit:</p><pre><code class="language-julia hljs">mask_energies!(data, 0, 15)
result = fit(prob, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[<span class="sgr36">PhotoelectricAbsorption * PowerLaw</span>]
│   . u     : [21.584, 2.2307, 0.53199]
│   . σᵤ    : [4.2347, 0.12576, 0.27277]
│   . χ²    : 43.970 
└ </code></pre><pre><code class="language-julia hljs">plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10
)
plot!(data, result, label = &quot;PowerLaw&quot;)</code></pre><img src="16f0d5a1.svg" alt="Example block output"/><p>The result is not yet baked into our model, and represents just the outcome of the fit. To update the parameters and errors in the model, we can use <a href="@ref"><code>update_model!</code></a></p><pre><code class="language-julia hljs">update_model!(model, result)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 model components:
│ <span class="sgr36">     m1 * a1</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_1 -&gt;   21.6 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;   2.23 ± 0.3  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;  0.532 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since fitting and updating a model is often done in tandem, SpectralFitting.jl has both a <a href="@ref"><code>fit</code></a> and <a href="@ref"><code>fit!</code></a> method, the latter automatically updates the model parameters after fit.</p></div></div><p>To estimate the goodness of our fit, we can mimic the <code>goodness</code> command from XSPEC. This will use the <a href="@ref"><code>simulate</code></a> function to simulate spectra for a dataset (here determined by the result), and fit the model to the simulated dataset. The fit statistic for each fit is then appended to an array, which we can use to plot a histogram:</p><pre><code class="language-julia hljs">spread = goodness(result; N = 1000, seed = 42, exposure_time = data.data.spectrum.exposure_time)
histogram(spread, ylims = (0, 300), label = &quot;Simulated&quot;)
vline!([result.χ2], label = &quot;Best fit&quot;)</code></pre><img src="a8154f1d.svg" alt="Example block output"/><p>Note we have set the random number generator seed with <code>seed = 42</code> to allow our results to be strictly reproduced.</p><p>The <code>goodness</code> command will log the percent of simulations with a fit statistic better than the result, but we can equivalently calculate that ourselves:</p><pre><code class="language-julia hljs">count(&lt;(result.χ2), spread) * 100 / length(spread)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">56.9</code></pre><p>Next we want to calculate the flux in an energy range observed by the detector. We can do this with <a href="@ref"><code>LogFlux</code></a> or <a href="../models/models/#SpectralFitting.XS_CalculateFlux"><code>XS_CalculateFlux</code></a>, as they are both equivalent implementations.</p><p>We can modify our model by accessing properties from the model card and writing a new expression:</p><pre><code class="language-julia hljs">calc_flux = XS_CalculateFlux(
    E_min = FitParam(0.2, frozen = true),
    E_max = FitParam(2.0, frozen = true),
    log10Flux = FitParam(-10.3, lower_limit = -100, upper_limit = 100),
)

flux_model = model.m1 * calc_flux(model.a1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 model components:
│ <span class="sgr36">     m1 * c1(a1)</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">PowerLaw</span>
│              K_1 -&gt;   21.6 ± 0.1   ∈ [    0, Inf ]<span class="sgr32">   FREE</span>
│              a_1 -&gt;   2.23 ± 0.3   ∈ [    0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   c1</span> =&gt; <span class="sgr36">XS_CalculateFlux</span>
│          E_min_1 -&gt;    0.2<span class="sgr36">                             FROZEN</span>
│          E_max_1 -&gt;      2<span class="sgr36">                             FROZEN</span>
│      log10Flux_1 -&gt;  -10.3 ± 1     ∈ [ -100, 100 ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│             ηH_1 -&gt;  0.532 ± 0.1   ∈ [    0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><p>Since we used the old model to define the new one, our best fit values are automatically copied into the new model. We can now freeze the normalization, as we are using the flux integrating model to scale the powerlaw component:</p><pre><code class="language-julia hljs">flux_model.a1.K.frozen = true
flux_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 model components:
│ <span class="sgr36">     m1 * c1(a1)</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">PowerLaw</span>
│              K_1 -&gt;   21.6<span class="sgr36">                             FROZEN</span>
│              a_1 -&gt;   2.23 ± 0.3   ∈ [    0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   c1</span> =&gt; <span class="sgr36">XS_CalculateFlux</span>
│          E_min_1 -&gt;    0.2<span class="sgr36">                             FROZEN</span>
│          E_max_1 -&gt;      2<span class="sgr36">                             FROZEN</span>
│      log10Flux_1 -&gt;  -10.3 ± 1     ∈ [ -100, 100 ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│             ηH_1 -&gt;  0.532 ± 0.1   ∈ [    0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><p>Looking at the data card, we see the fit domain does not include the full region that we want to integrate the flux over. We therefore need to extend the fitting domain:</p><pre><code class="language-julia hljs">flux_problem = FittingProblem(flux_model =&gt; data)
# TODO: domain extensions not fully implemented yet</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingProblem:
│   Models:
│     . CompositeModel[<span class="sgr36">PhotoelectricAbsorption * XS_CalculateFlux(PowerLaw)</span>]
│   Data:
│     . OGIPDataset[[no observation id]]
└ </code></pre><p>Now to fit we can repeat the above procedure, and even overplot the region of flux we integrated:</p><pre><code class="language-julia hljs">flux_result = fit(flux_problem, LevenbergMarquadt())

plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10
)
plot!(data, flux_result)
vspan!([flux_model.c1.E_min.value, flux_model.c1.E_max.value], alpha = 0.5)</code></pre><img src="d1440782.svg" alt="Example block output"/><p>Let&#39;s try alternative models to see how they fit the data. First, an absorbed black body:</p><pre><code class="language-julia hljs">model2 = PhotoelectricAbsorption() * XS_BlackBody()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 model components:
│ <span class="sgr36">     m1 * a1</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">XS_BlackBody</span>
│       K_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       T_1 -&gt;  3 ± 0.3  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><p>We fit in the same way as before:</p><pre><code class="language-julia hljs">prob2 = FittingProblem(model2 =&gt; data)
result2 = fit!(prob2, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[<span class="sgr36">PhotoelectricAbsorption * XS_BlackBody</span>]
│   . u     : [0.46462, 0.89091, 0.0]
│   . σᵤ    : [0.022068, 0.032552, 0.27922]
│   . χ²    : 123.78 
└ </code></pre><p>Let&#39;s overplot this result against our power law result:</p><pre><code class="language-julia hljs">dp = plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10,
    legend = :bottomleft,
)
plot!(dp, data, result, label = &quot;PowerLaw $(round(result.χ2))&quot;)
plot!(dp, data, result2, label = &quot;BlackBody $(round(result2.χ2))&quot;)</code></pre><img src="683a03e0.svg" alt="Example block output"/><p>Or a bremsstrahlung model:</p><pre><code class="language-julia hljs">model3 = PhotoelectricAbsorption() * XS_BremsStrahlung()
prob3 = FittingProblem(model3 =&gt; data)
result3 = fit(prob3, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[<span class="sgr36">PhotoelectricAbsorption * XS_BremsStrahlung</span>]
│   . u     : [13.868, 5.3034, 0.0]
│   . σᵤ    : [1.3178, 0.70705, 0.19664]
│   . χ²    : 40.027 
└ </code></pre><pre><code class="language-julia hljs">plot!(dp, data, result3, label = &quot;Brems $(round(result3.χ2))&quot;)</code></pre><img src="9d751175.svg" alt="Example block output"/><p>Let&#39;s take a look at the residuals of these three models. There are utility methods for this in SpectralFitting.jl, but we can easily just interact with the result directly:</p><pre><code class="language-julia hljs">function residuals(result)
    # select which result we want (only have one, but for generalisation to multi-model fits)
    r = result[1]
    y = invoke_result(r)
    @. (r.objective - y) / sqrt(r.variance)
end

domain = SpectralFitting.plotting_domain(data)

rp = hline([0], linestyle = :dash, legend = false)
plot!(rp,domain, residuals(result), seriestype = :stepmid)
plot!(rp, domain, residuals(result2), seriestype = :stepmid)
plot!(rp, domain, residuals(result3), seriestype = :stepmid)
rp</code></pre><img src="021f0173.svg" alt="Example block output"/><p>We can compose this figure with our previous one, and change to a linear x scale:</p><pre><code class="language-julia hljs">plot(dp, rp, layout = grid(2, 1, heights = [0.7, 0.3]), link = :x, xscale = :linear)</code></pre><img src="0175dba2.svg" alt="Example block output"/><p>Let&#39;s modify the black body model with a continuum component</p><pre><code class="language-julia hljs">bbpl_model = model2.m1 * (PowerLaw() + model2.a1) |&gt; deepcopy</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 model components:
│ <span class="sgr36">     m1 * (a2 + a1)</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">XS_BlackBody</span>
│       K_1 -&gt;  0.465 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       T_1 -&gt;  0.891 ± 0.3  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   a2</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_2 -&gt;      1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;      2 ± 0.2  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;      0 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We pipe the model to <code>deepcopy</code> to create a copy of all the model parameters. Not doing this means the parameters in <code>bbpl_model</code> will be aliased to the parameters in <code>model2</code>, and changing one with change the other.</p></div></div><p>We&#39;ll freeze the hydrogen column density parameter to the galactic value and refit:</p><pre><code class="language-julia hljs">bbpl_model.ηH_1.value = 4
bbpl_model.ηH_1.frozen = true
bbpl_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 model components:
│ <span class="sgr36">     m1 * (a2 + a1)</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">XS_BlackBody</span>
│       K_1 -&gt;  0.465 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       T_1 -&gt;  0.891 ± 0.3  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   a2</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_2 -&gt;      1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;      2 ± 0.2  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;      4<span class="sgr36">                         FROZEN</span>
└ </code></pre><p>And fitting:</p><pre><code class="language-julia hljs">bbpl_result = fit(
    FittingProblem(bbpl_model =&gt; data),
    LevenbergMarquadt()
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[<span class="sgr36">PhotoelectricAbsorption * (PowerLaw + XS_BlackBody)</span>]
│   . u     : [83.697, 0.15572, 77.052, 2.9226]
│   . σᵤ    : [66.153, 0.015973, 12.743, 0.11682]
│   . χ²    : 40.864 
└ </code></pre><p>Let&#39;s plot the result:</p><pre><code class="language-julia hljs">plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10,
    legend = :bottomleft,
)
plot!(data, bbpl_result)</code></pre><img src="e2887414.svg" alt="Example block output"/><p>Update the model and fix the black body temperature to 2 keV:</p><pre><code class="language-julia hljs">update_model!(bbpl_model, bbpl_result)

bbpl_model.T_1.value = 2.0
bbpl_model.T_1.frozen = true
bbpl_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 model components:
│ <span class="sgr36">     m1 * (a2 + a1)</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">XS_BlackBody</span>
│       K_1 -&gt;  83.7 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       T_1 -&gt;     2<span class="sgr36">                        FROZEN</span>
│ <span class="sgr36">   a2</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_2 -&gt;  77.1 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;  2.92 ± 0.2  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;     4<span class="sgr36">                        FROZEN</span>
└ </code></pre><p>Fitting:</p><pre><code class="language-julia hljs">bbpl_result2 = fit(
    FittingProblem(bbpl_model =&gt; data),
    LevenbergMarquadt()
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[<span class="sgr36">PhotoelectricAbsorption * (PowerLaw + XS_BlackBody)</span>]
│   . u     : [0.38234, 573.17, 4.8351]
│   . σᵤ    : [0.034796, 83.183, 0.16012]
│   . χ²    : 71.708 
└ </code></pre><p>Overplotting this new result:</p><pre><code class="language-julia hljs">plot!(data, bbpl_result2)</code></pre><img src="f45dd998.svg" alt="Example block output"/><h2 id="MCMC"><a class="docs-heading-anchor" href="#MCMC">MCMC</a><a id="MCMC-1"></a><a class="docs-heading-anchor-permalink" href="#MCMC" title="Permalink"></a></h2><p>We can use libraries like <a href="https://pigeons.run/dev/">Pidgeons.jl</a> or <a href="https://turinglang.org/">Turing.jl</a> to perform Bayesian inference on our paramters. SpectralFitting.jl is designed with <em>BYOO</em> (Bring Your Own Optimizer) in mind, and so makes it relatively easy to get at the core fitting functions to be used with other packages.</p><p>Let&#39;s use Turing.jl here, which means we&#39;ll also want to use <a href="https://docs.juliaplots.org/dev/generated/statsplots/">StatsPlots.jl</a> to plot our walker chains.</p><pre><code class="language-julia hljs">using StatsPlots
using Turing</code></pre><p>Turing.jl provides enormous control over the definition of the model, and this is not control SpectralFitting.jl wants to take away from you. Although we will provide utility scripts to do the basics, here we&#39;ll show you everything step by step to give you an overview of what you can do.</p><p>Let&#39;s go back to our first model:</p><pre><code class="language-julia hljs">model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 model components:
│ <span class="sgr36">     m1 * a1</span>
│ Model key and parameters:
│ <span class="sgr36">   a1</span> =&gt; <span class="sgr36">PowerLaw</span>
│       K_1 -&gt;   21.6 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│       a_1 -&gt;   2.23 ± 0.3  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
│ <span class="sgr36">   m1</span> =&gt; <span class="sgr36">PhotoelectricAbsorption</span>
│      ηH_1 -&gt;  0.532 ± 0.1  ∈ [ 0, Inf ]<span class="sgr32">   FREE</span>
└ </code></pre><p>This gave a pretty good fit but the errors on our paramters are not well defined, being estimated only from a convariance matrix in the least-squares solver. MCMC can give us better confidence regions, and even help us uncover dependencies between paramters. Here we&#39;ll take all of our parameters and convert them into a Turing.jl model with use of their macro:</p><pre><code class="language-julia hljs">@model function mcmc_model(domain, objective, variance, f)
    K ~ Normal(20.0, 1.0)
    a ~ Normal(2.2, 0.3)
    ηH ~ truncated(Normal(0.5, 0.1); lower = 0)

    pred = f(domain, [K, a, ηH])
    return objective ~ MvNormal(pred, sqrt.(variance))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">mcmc_model (generic function with 2 methods)</code></pre><p>A few things to note here: we use the Turing.jl sampling syntax <code>~</code> to say that a variable is sampled from a certain type of prior distribution. There are no fixed criteria for what a distribution can be, and we encourage you to consult the Turing.jl documentation to learn how to define your own custom probability distributions. In this case, we will use Gaussians for all our parameters, and for the means and standard deviations use the best fit and estimated errors.</p><p>At the moment we haven&#39;t explicitly used our model, but <code>f</code> in this case takes the roll of invoking our model, and folding through instrument responses. We call it in much the same way as <a href="../models/using-models/#SpectralFitting.invokemodel"><code>invokemodel</code></a>, despite it going the extra step to fold our model. To instantiate this, we can use the SpectralFitting.jl helper functions:</p><pre><code class="language-julia hljs">config = FittingConfig(FittingProblem(model =&gt; data))
mm = mcmc_model(
    make_model_domain(ContiguouslyBinned(), data),
    make_objective(ContiguouslyBinned(), data),
    make_objective_variance(ContiguouslyBinned(), data),
    # _f_objective returns a function used to evaluate and fold the model through the data
    SpectralFitting._f_objective(config),
)</code></pre><p>That&#39;s it! We&#39;re now ready to sample our model. Since all our models are implemented in Julia, we can use gradient-boosted samplers with automatic differentiation, such as NUTS. We&#39;ll walk 5000 itterations, just as a small example:</p><pre><code class="language-julia hljs">chain = sample(mm, NUTS(), 5_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (5000×15×1 Array{Float64, 3}):

Iterations        = 1001:1:6000
Number of chains  = 1
Samples per chain = 5000
Wall duration     = 14.96 seconds
Compute duration  = 14.96 seconds
parameters        = K, a, ηH
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse    ess_bulk    ess_tail      rhat   ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64     Float64     Float64   Float64   ⋯

           K   20.2711    0.8423    0.0205   1695.9820   2192.3731    0.9999   ⋯
           a    2.1880    0.0332    0.0008   1790.1477   2251.1341    0.9999   ⋯
          ηH    0.4712    0.0745    0.0016   2234.7969   1915.4065    1.0000   ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

           K   18.6898   19.6935   20.2662   20.8458   21.9474
           a    2.1239    2.1650    2.1877    2.2106    2.2530
          ηH    0.3310    0.4201    0.4708    0.5198    0.6214
</span></span></code></pre><p>In the printout we see summary statistics about or model, in this case that it has converged well (<code>rhat</code> close to 1 for all parameters), better estimates of the standard deviation, and various quantiles. We can plot our chains to make sure the caterpillers are healthy and fuzzy, making use of StatsPlots.jl recipes:</p><pre><code class="language-julia hljs">plot(chain)</code></pre><img src="117c13d2.svg" alt="Example block output"/><p>Corner plots are currently broken at time of writing.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/examples/">Diverse examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 26 May 2024 10:15">Sunday 26 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
