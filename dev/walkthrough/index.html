<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Walkthrough · SpectralFitting.jl</title><meta name="title" content="Walkthrough · SpectralFitting.jl"/><meta property="og:title" content="Walkthrough · SpectralFitting.jl"/><meta property="twitter:title" content="Walkthrough · SpectralFitting.jl"/><meta name="description" content="Documentation for SpectralFitting.jl."/><meta property="og:description" content="Documentation for SpectralFitting.jl."/><meta property="twitter:description" content="Documentation for SpectralFitting.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SpectralFitting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralFitting.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Walkthrough</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li></ul></li><li><a class="tocitem" href="../why-and-how/">Why &amp; How</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../using-models/">Using models</a></li><li><a class="tocitem" href="../models/">Model index</a></li><li><a class="tocitem" href="../composite-models/">Composite models</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Walkthrough</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Walkthrough</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fjebaker/SpectralFitting.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fjebaker/SpectralFitting.jl/blob/main/docs/src/walkthrough.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Walkthrough"><a class="docs-heading-anchor" href="#Walkthrough">Walkthrough</a><a id="Walkthrough-1"></a><a class="docs-heading-anchor-permalink" href="#Walkthrough" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This walk through has not been fleshed out with the relevant astrophysical content yet (for example, whether a fit is good, what the different parameters mean, etc.), and so assumes some familarity with spectral fitting in general.</p><p>It is also not yet complete, nor a faithful illustration of everything SpectralFitting.jl can do. It serves to illustrate similarities and differences in syntax between SpectralFitting.jl and XSPEC.</p></div></div><p>This example walkthrough is the SpectralFitting.jl equivalent of the <a href="https://heasarc.gsfc.nasa.gov/docs/xanadu/xspec/manual/node35.html">Walk through XSPEC</a> from the XSPEC manual. We will use the same dataset, available for download from this <a href="https://heasarc.gsfc.nasa.gov/docs/xanadu/xspec/walkthrough.tar.gz">link to the data files</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The first thing we want to do is load our datasets. Unlike in XSPEC, we have no requirement of being in the same directory as the data, or even that all of the response, ancillary, and spectral files be in the same place. For simplicity, we&#39;ll assume they are:</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Be sure to set <code>DATADIR</code> pointing to the directory where you keep the walkthrough data.</p></div></div><pre><code class="language-julia hljs">using SpectralFitting, Plots

DATADIR = &quot;...&quot;
spec1_path = joinpath(DATADIR, &quot;s54405.pha&quot;)
data = OGIPDataset(spec1_path)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ OGIPDataset:
│   . Object              : 1E 1048-5937
│   . Observation ID      : [no observation id]
│   . Exposure ID         : [no exposure id]
│ SpectralData with 125 active channels:
│   . Chn. E (min/max)    : (0.69357, 70.563)
│   . Masked channels     : 0 / 125
│   . Model domain size   : 129
│   . Domain (min/max)    : (0.44347, 36.632)
│ Primary Spectrum:
│  Spectrum: EXOSAT[ME]
│   Units                 : counts s^-1
│   . Exposure time       : 23580.0
│   . Channels            : 125
│   . Data (min/max)      : (-0.028499, 0.30515)
│   . Grouped             : yes
│   . Bad channels        : yes (40)
│ Response:
│  Response Matrix (125 x 128) channels:
│   . Chn. E (min/max)    : (0.69357, 70.563)
│   . Domain E (min/max)  : (0.44347, 36.632)
│ Background: nothing
│ Ancillary: nothing
└ </code></pre><p>This will print a little card about our data, which shows us what else SpectralFitting.jl loaded. We can see the <code>Primary Spectrum</code>, the <code>Response</code>, but that the <code>Background</code> and <code>Ancillary</code> response files are missing. That&#39;s to be expected, since we don&#39;t have those files in the dataset. </p><p>We can check what paths it used by looking at</p><pre><code class="language-julia hljs">data.paths</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SpectralFilePaths:
  . Spectrum       : /home/runner/work/SpectralFitting.jl/SpectralFitting.jl/docs/build/../../ex-datadir/s54405.pha
  . Response       : /home/runner/work/SpectralFitting.jl/SpectralFitting.jl/docs/build/../../ex-datadir/s54405.rsp
  . Background     : nothing
  . Ancillary      : nothing
</code></pre><p>We can load and alter any part of a dataset as we do our fitting. For example, if you have multiple different ancillary files at hand, switching them between fits is a one-liner.</p><p>To visualize our data, we can use some of the <a href="https://docs.juliaplots.org/latest/">Plots.jl</a> recipes included in SpectralFitting.jl:</p><pre><code class="language-julia hljs">plot(data, xlims = (0.5, 70), xscale = :log10)</code></pre><img src="c3f23784.svg" alt="Example block output"/><p>Note that the units are currently not divided by the energy bin widths. We can either do that manually, or use the <a href="@ref"><code>normalize!</code></a> to convert whatever units the data is currently in to the defacto standard <code>counts s⁻¹ keV⁻¹</code> for fitting. Whilst we&#39;re at it, we see in the model card that there are 40 <a href="https://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/spectra/ogip_92_007.pdf">bad quality bins</a> still present in our data. We can drop those as well, and plot the data on log-log axes:</p><pre><code class="language-julia hljs">normalize!(data)
drop_bad_channels!(data)
plot(data, ylims = (0.001, 2.0), yscale = :log10, xscale = :log10)</code></pre><img src="c091c6a1.svg" alt="Example block output"/><p>Note that when there are no negative axes, the scale defaults to log on the plot unless otherwise specified.</p><p>Next we want to specify a model to fit to this data. Models that are prefixed with <code>XS_</code> are models that are linked from the XSPEC model library, provided via <a href="https://github.com/astro-group-bristol/LibXSPEC_jll.jl">LibXSPEC_jll</a>. For a full list of the models, see <a href="@ref">Models library</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is advised to <strong>use the Julia implemented models</strong>. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see <a href="../why-and-how/#Why-and-how">Why &amp; how</a>.</p></div></div><p>We will start by fitting a photoelectric absorption model that acts on a power law model:</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To see information about a model, use the <code>?</code> in the Julia REPL:</p><pre><code class="language-julia hljs">julia&gt; ?PowerLaw
XS_PowerLaw(K, a)

    •  K: Normalisation.

    •  a: Photon index.

Example
≡≡≡≡≡≡≡
...</code></pre></div></div><pre><code class="language-julia hljs">model = PhotoelectricAbsorption() * PowerLaw()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 component models:
│      m1 * a1
│ Model key and parameters:
│    a1 =&gt; PowerLaw
│       K_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]   FREE
│       a_1 -&gt;  2 ± 0.2  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]   FREE
└ </code></pre><p>If we want to specify paramters of our model at instantiation, we can do that with</p><pre><code class="language-julia hljs">model = PhotoelectricAbsorption() * PowerLaw(a = FitParam(3.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 component models:
│      m1 * a1
│ Model key and parameters:
│    a1 =&gt; PowerLaw
│       K_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]   FREE
│       a_1 -&gt;  3 ± 0.3  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]   FREE
└ </code></pre><p>SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a <a href="@ref"><code>FittingProblem</code></a>:</p><pre><code class="language-julia hljs">prob = FittingProblem(model =&gt; data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingProblem:
│   Models:
│     . CompositeModel[PhotoelectricAbsorption * PowerLaw]
│   Data:
│     . OGIPDataset[[no observation id]]
└ </code></pre><p>SpectralFitting.jl makes a huge wealth of optimizers availble from <a href="https://github.com/SciML/Optimization.jl">Optimizations.jl</a>, and others from further afield. For consistency with XSPEC, we&#39;ll use here a delayed-gratification least-squares algorithm from <a href="https://github.com/JuliaNLSolvers/LsqFit.jl">LsqFit.jl</a>:</p><pre><code class="language-julia hljs">result = fit(prob, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[PhotoelectricAbsorption * PowerLaw]
│   . u     : [22.181, 2.2488, 0.56637]
│   . σᵤ    : [4.3720, 0.12638, 0.27433]
│   . χ²    : 108.94 
└ </code></pre><p>Here we can see the parameter vector, the estimated error on each parameter, and the measure of the fit statistic (here chi squared). We can overplot our result on our data easily:</p><pre><code class="language-julia hljs">plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10
)
plot!(data, result)</code></pre><img src="90887705.svg" alt="Example block output"/><p>Our model does not account for the high energy range well. We can ignore that range for now, and select everything from 0 to 15 keV and refit:</p><pre><code class="language-julia hljs">mask_energies!(data, 0, 15)
result = fit(prob, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[PhotoelectricAbsorption * PowerLaw]
│   . u     : [21.584, 2.2307, 0.53199]
│   . σᵤ    : [4.2347, 0.12576, 0.27277]
│   . χ²    : 43.970 
└ </code></pre><pre><code class="language-julia hljs">plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10
)
plot!(data, result, label = &quot;PowerLaw&quot;)</code></pre><img src="284610b3.svg" alt="Example block output"/><p>The result is not yet baked into our model, and represents just the outcome of the fit. To update the parameters and errors in the model, we can use <a href="@ref"><code>update_model!</code></a></p><pre><code class="language-julia hljs">update_model!(model, result)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 component models:
│      m1 * a1
│ Model key and parameters:
│    a1 =&gt; PowerLaw
│       K_1 -&gt;   21.6 ± 0.1  ∈ [ 0, Inf ]   FREE
│       a_1 -&gt;   2.23 ± 0.3  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;  0.532 ± 0.1  ∈ [ 0, Inf ]   FREE
└ </code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since fitting and updating a model is often done in tandem, SpectralFitting.jl has both a <a href="@ref"><code>fit</code></a> and <a href="@ref"><code>fit!</code></a> method, the latter automatically updates the model parameters after fit.</p></div></div><p>To estimate the goodness of our fit, we can mimic the <code>goodness</code> command from XSPEC. This will use the <a href="@ref"><code>simulate</code></a> function to simulate spectra for a dataset (here determined by the result), and fit the model to the simulated dataset. The fit statistic for each fit is then appended to an array, which we can use to plot a histogram:</p><pre><code class="language-julia hljs">spread = goodness(result; N = 1000, seed = 42)
histogram(spread, ylims = (0, 300), label = &quot;Simulated&quot;)
vline!([result.χ2], label = &quot;Best fit&quot;)</code></pre><img src="42dab9b1.svg" alt="Example block output"/><p>Note we have set the random number generator seed with <code>seed = 42</code> to allow our results to be strictly reproduced.</p><p>The <code>goodness</code> command will log the percent of simulations with a fit statistic better than the result, but we can equivalently calculate that ourselves:</p><pre><code class="language-julia hljs">count(&lt;(result.χ2), spread) * 100 / length(spread)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100.0</code></pre><p>Next we want to calculate the flux in an energy range observed by the detector. We can do this with <a href="@ref"><code>LogFlux</code></a> or <a href="../models/#SpectralFitting.XS_CalculateFlux"><code>XS_CalculateFlux</code></a>, as they are both equivalent implementations.</p><p>We can modify our model by accessing properties from the model card and writing a new expression:</p><pre><code class="language-julia hljs">calc_flux = XS_CalculateFlux(
    E_min = FitParam(0.2, frozen = true),
    E_max = FitParam(2.0, frozen = true),
    log10Flux = FitParam(-10.3, lower_limit = -100, upper_limit = 100),
)

flux_model = model.m1 * calc_flux(model.a1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 component models:
│      m1 * c1(a1)
│ Model key and parameters:
│    a1 =&gt; PowerLaw
│              K_1 -&gt;   21.6 ± 0.1   ∈ [    0, Inf ]   FREE
│              a_1 -&gt;   2.23 ± 0.3   ∈ [    0, Inf ]   FREE
│    c1 =&gt; XS_CalculateFlux
│          E_min_1 -&gt;    0.2                             FROZEN
│          E_max_1 -&gt;      2                             FROZEN
│      log10Flux_1 -&gt;  -10.3 ± 1     ∈ [ -100, 100 ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│             ηH_1 -&gt;  0.532 ± 0.1   ∈ [    0, Inf ]   FREE
└ </code></pre><p>Since we used the old model to define the new one, our best fit values are automatically copied into the new model. We can now freeze the normalization, as we are using the flux integrating model to scale the powerlaw component:</p><pre><code class="language-julia hljs">flux_model.a1.K.frozen = true
flux_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 component models:
│      m1 * c1(a1)
│ Model key and parameters:
│    a1 =&gt; PowerLaw
│              K_1 -&gt;   21.6                             FROZEN
│              a_1 -&gt;   2.23 ± 0.3   ∈ [    0, Inf ]   FREE
│    c1 =&gt; XS_CalculateFlux
│          E_min_1 -&gt;    0.2                             FROZEN
│          E_max_1 -&gt;      2                             FROZEN
│      log10Flux_1 -&gt;  -10.3 ± 1     ∈ [ -100, 100 ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│             ηH_1 -&gt;  0.532 ± 0.1   ∈ [    0, Inf ]   FREE
└ </code></pre><p>Looking at the data card, we see the fit domain does not include the full region that we want to integrate the flux over. We therefore need to extend the fitting domain:</p><pre><code class="language-julia hljs">flux_problem = FittingProblem(flux_model =&gt; data)
# TODO: domain extensions not fully implemented yet</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingProblem:
│   Models:
│     . CompositeModel[PhotoelectricAbsorption * XS_CalculateFlux(PowerLaw)]
│   Data:
│     . OGIPDataset[[no observation id]]
└ </code></pre><p>Now to fit we can repeat the above procedure, and even overplot the region of flux we integrated:</p><pre><code class="language-julia hljs">flux_result = fit(flux_problem, LevenbergMarquadt())

plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10
)
plot!(data, flux_result)
vspan!([flux_model.c1.E_min.value, flux_model.c1.E_max.value], alpha = 0.5)</code></pre><img src="68c2d6b7.svg" alt="Example block output"/><p>Let&#39;s try alternative models to see how they fit the data. First, an absorbed black body:</p><pre><code class="language-julia hljs">model2 = PhotoelectricAbsorption() * XS_BlackBody()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 2 component models:
│      m1 * a1
│ Model key and parameters:
│    a1 =&gt; XS_BlackBody
│       K_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]   FREE
│       T_1 -&gt;  3 ± 0.3  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;  1 ± 0.1  ∈ [ 0, Inf ]   FREE
└ </code></pre><p>We fit in the same way as before:</p><pre><code class="language-julia hljs">prob2 = FittingProblem(model2 =&gt; data)
result2 = fit!(prob2, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[PhotoelectricAbsorption * XS_BlackBody]
│   . u     : [0.46462, 0.89091, 0.0]
│   . σᵤ    : [0.022068, 0.032552, 0.27922]
│   . χ²    : 123.78 
└ </code></pre><p>Let&#39;s overplot this result against our power law result:</p><pre><code class="language-julia hljs">dp = plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10,
    legend = :bottomleft,
)
plot!(dp, data, result, label = &quot;PowerLaw $(round(result.χ2))&quot;)
plot!(dp, data, result2, label = &quot;BlackBody $(round(result2.χ2))&quot;)</code></pre><img src="208cd72f.svg" alt="Example block output"/><p>Or a bremsstrahlung model:</p><pre><code class="language-julia hljs">model3 = PhotoelectricAbsorption() * XS_BremsStrahlung()
prob3 = FittingProblem(model3 =&gt; data)
result3 = fit(prob3, LevenbergMarquadt())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[PhotoelectricAbsorption * XS_BremsStrahlung]
│   . u     : [13.868, 5.3034, 0.0]
│   . σᵤ    : [1.3178, 0.70705, 0.19664]
│   . χ²    : 40.027 
└ </code></pre><pre><code class="language-julia hljs">plot!(dp, data, result3, label = &quot;Brems $(round(result3.χ2))&quot;)</code></pre><img src="79691517.svg" alt="Example block output"/><p>Let&#39;s take a look at the residuals of these three models. There are utility methods for this in SpectralFitting.jl, but we can easily just interact with the result directly:</p><pre><code class="language-julia hljs">function residuals(result)
    # select which result we want (only have one, but for generalisation to multi-model fits)
    r = result[1]
    y = invoke_result(r)
    @. (r.objective - y) / sqrt(r.variance)
end

domain = SpectralFitting.plotting_domain(data)

rp = hline([0], linestyle = :dash, legend = false)
plot!(rp,domain, residuals(result), seriestype = :stepmid)
plot!(rp, domain, residuals(result2), seriestype = :stepmid)
plot!(rp, domain, residuals(result3), seriestype = :stepmid)
rp</code></pre><img src="d02dbeef.svg" alt="Example block output"/><p>We can compose this figure with our previous one, and change to a linear x scale:</p><pre><code class="language-julia hljs">plot(dp, rp, layout = grid(2, 1, heights = [0.7, 0.3]), link = :x, xscale = :linear)</code></pre><img src="b76b52e2.svg" alt="Example block output"/><p>Let&#39;s modify the black body model with a continuum component</p><pre><code class="language-julia hljs">bbpl_model = model2.m1 * (PowerLaw() + model2.a1) |&gt; deepcopy</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 component models:
│      m1 * (a2 + a1)
│ Model key and parameters:
│    a1 =&gt; XS_BlackBody
│       K_1 -&gt;  0.465 ± 0.1  ∈ [ 0, Inf ]   FREE
│       T_1 -&gt;  0.891 ± 0.3  ∈ [ 0, Inf ]   FREE
│    a2 =&gt; PowerLaw
│       K_2 -&gt;      1 ± 0.1  ∈ [ 0, Inf ]   FREE
│       a_1 -&gt;      2 ± 0.2  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;      0 ± 0.1  ∈ [ 0, Inf ]   FREE
└ </code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We pipe the model to <code>deepcopy</code> to create a copy of all the model parameters. Not doing this means the parameters in <code>bbpl_model</code> will be aliased to the parameters in <code>model2</code>, and changing one with change the other.</p></div></div><p>We&#39;ll freeze the hydrogen column density parameter to the galactic value and refit:</p><pre><code class="language-julia hljs">bbpl_model.ηH_1.value = 4
bbpl_model.ηH_1.frozen = true
bbpl_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 component models:
│      m1 * (a2 + a1)
│ Model key and parameters:
│    a1 =&gt; XS_BlackBody
│       K_1 -&gt;  0.465 ± 0.1  ∈ [ 0, Inf ]   FREE
│       T_1 -&gt;  0.891 ± 0.3  ∈ [ 0, Inf ]   FREE
│    a2 =&gt; PowerLaw
│       K_2 -&gt;      1 ± 0.1  ∈ [ 0, Inf ]   FREE
│       a_1 -&gt;      2 ± 0.2  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;      4                         FROZEN
└ </code></pre><p>And fitting:</p><pre><code class="language-julia hljs">bbpl_result = fit(
    FittingProblem(bbpl_model =&gt; data),
    LevenbergMarquadt()
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[PhotoelectricAbsorption * (PowerLaw + XS_BlackBody)]
│   . u     : [83.697, 0.15572, 77.052, 2.9226]
│   . σᵤ    : [66.153, 0.015973, 12.743, 0.11682]
│   . χ²    : 40.864 
└ </code></pre><p>Let&#39;s plot the result:</p><pre><code class="language-julia hljs">plot(data,
    ylims = (0.001, 2.0),
    xscale = :log10,
    yscale = :log10,
    legend = :bottomleft,
)
plot!(data, bbpl_result)</code></pre><img src="85c578d9.svg" alt="Example block output"/><p>Update the model and fix the black body temperature to 2 keV:</p><pre><code class="language-julia hljs">update_model!(bbpl_model, bbpl_result)

bbpl_model.T_1.value = 2.0
bbpl_model.T_1.frozen = true
bbpl_model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ CompositeModel with 3 component models:
│      m1 * (a2 + a1)
│ Model key and parameters:
│    a1 =&gt; XS_BlackBody
│       K_1 -&gt;  83.7 ± 0.1  ∈ [ 0, Inf ]   FREE
│       T_1 -&gt;     2                        FROZEN
│    a2 =&gt; PowerLaw
│       K_2 -&gt;  77.1 ± 0.1  ∈ [ 0, Inf ]   FREE
│       a_1 -&gt;  2.92 ± 0.2  ∈ [ 0, Inf ]   FREE
│    m1 =&gt; PhotoelectricAbsorption
│      ηH_1 -&gt;     4                        FROZEN
└ </code></pre><p>Fitting:</p><pre><code class="language-julia hljs">bbpl_result2 = fit(
    FittingProblem(bbpl_model =&gt; data),
    LevenbergMarquadt()
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ FittingResult:
│   Model: CompositeModel[PhotoelectricAbsorption * (PowerLaw + XS_BlackBody)]
│   . u     : [0.38234, 573.17, 4.8351]
│   . σᵤ    : [0.034796, 83.183, 0.16012]
│   . χ²    : 71.708 
└ </code></pre><p>Overplotting this new result:</p><pre><code class="language-julia hljs">plot!(data, bbpl_result2)</code></pre><img src="3737b1ca.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../why-and-how/">Why &amp; How »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 14 May 2024 00:39">Tuesday 14 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
