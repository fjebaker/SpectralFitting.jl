var documenterSearchIndex = {"docs":
[{"location":"transitioning-from-xspec/#Transitioning-from-XSPEC","page":"Transitioning from XSPEC","title":"Transitioning from XSPEC","text":"","category":"section"},{"location":"why-and-how/#Why-and-how","page":"Why & How","title":"Why & how","text":"","category":"section"},{"location":"fitting/#Fitting-spectral-models","page":"Fitting","title":"Fitting spectral models","text":"","category":"section"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Models exist as three different kinds","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"AbstractSpectralModelKind\nmodelkind\nAdditive\nMultiplicative\nConvolutional","category":"page"},{"location":"models/#SpectralFitting.AbstractSpectralModelKind","page":"Models","title":"SpectralFitting.AbstractSpectralModelKind","text":"abstract type AbstractSpectralModelKind\n\nAbstract type of all model kinds.\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.modelkind","page":"Models","title":"SpectralFitting.modelkind","text":"modelkind(M::Type{<:AbstractSpectralModel})\n\nReturn the kind of model given by M: either Additive, Multiplicative, or Convolutional.\n\n\n\n\n\n","category":"function"},{"location":"models/#SpectralFitting.Additive","page":"Models","title":"SpectralFitting.Additive","text":"Additive <: AbstractSpectralModelKind\nAdditive()\n\nAdditive models are effectively the sources of photons, and are the principle building blocks of composite models.\n\nnote: Note\nDefining custom additive models requires special care. See Defining new models.\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.Multiplicative","page":"Models","title":"SpectralFitting.Multiplicative","text":"Multiplicative <: AbstractSpectralModelKind\nMultiplicative()\n\nMultiplicative models act on Additive models, by element-wise multiplying the flux in each energy bin of the additive model by a different factor.\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.Convolutional","page":"Models","title":"SpectralFitting.Convolutional","text":"Convolutional <: AbstractSpectralModelKind\nConvolutional()\n\nConvolutional models act on the flux generated by Additive models, similar to Multiplicative models, however may convolve kernels through the flux also.\n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Models","title":"Models","text":"Models wrapped from XSPEC implementations are prefixed with XS_*, whereas pure-Julia models are simply named, e.g. XS_PowerLaw in XSPEC vs PowerLaw in Julia.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The available models are","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Pages = [\"models.md\"]\nOrder = [:type]","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"AbstractSpectralModel\nSpectralFitting.invoke!","category":"page"},{"location":"models/#SpectralFitting.AbstractSpectralModel","page":"Models","title":"SpectralFitting.AbstractSpectralModel","text":"abstract type AbstractSpectralModel\n\nSupertype of all spectral models. Sub-types must implement the following interface\n\nmodelkind\nSpectralFitting.invoke!\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.invoke!","page":"Models","title":"SpectralFitting.invoke!","text":"SpectralFitting.invoke!(flux, energy, M::Type{<:AbstractSpectralModel}, params...)\n\nUsed to define the behaviour of models. Should calculate flux of the model and write in-place into flux.\n\nnote: Note\nThis function should not be called directly. Use invokemodel instead.\n\nParameters are passed in in-order as defined in the model structure. For example\n\nstruct MyModel{F1,F2,F3,...} <: AbstractSpectralModel\n    p1::F1\n    p2::F2\n    p3::F3\n    # ...\nend\n\nwould have the arguments passed to invoke! as\n\nfunction SpectralFitting.invoke!(flux, energy, ::Type{<:MyModel}, p1, p2, p3, ...)\n    # ...\nend\n\nThe only exception to this are Additive models, where the normalisation parameter K is not passed to invoke!.\n\n\n\n\n\n","category":"function"},{"location":"models/#Using-models","page":"Models","title":"Using models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"invokemodel","category":"page"},{"location":"models/#Defining-new-models","page":"Models","title":"Defining new models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"To define a new Julia model, we need only implement the AbstractSpectralModel interface. As a pedagogical example, consider an implementation of PowerLaw:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"# define the model and parameters\n@with_kw struct PowerLaw{F1,F2} <: AbstractSpectralModel\n    \"Normalisation.\"\n    K::F1 = FitParam(1.0)\n    \"Photon index.\"\n    a::F2 = FitParam(0.5)\nend\n\n# tell the package what kind of model this is\nmodelkind(::Type{<:PowerLaw}) = Additive()\n\n# define how the model acts: \n# all of the parameters are passed, in order, as arguments\nfunction SpectralFitting.invoke!(flux, energy, ::Type{<:PowerLaw}, a)\n    α = 1 - a\n    α⁻¹ = inv(α)\n    SpectralFitting.integrate_over_flux!(flux, energy) do E\n        α⁻¹ * E^α\n    end\nend","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Note that each parameter has its own parametric type, here ::F1 and ::F2. This is so that the type of fit parameters can be changed, or alternative number types inserted (see Why & how). The standard parameter type is FitParam, which is what we have used here.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The model is defined to be additive by overloading modelkind.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"note: Note\nAdditive models must have a normalisation parameter with the symbol K, which is, however, not passed to SpectralFitting.invoke!. Multiplicative and convolutional models have no such requirements.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"We have also used the SpectralFitting.integrate_over_flux utility function, which is designed to help us efficiently compute finite-difference integrations of flux, just as XSPEC does.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"note: Note\nTo add additional XSPEC models, see Wrapping new XSPEC models.","category":"page"},{"location":"models/#Julia-models","page":"Models","title":"Julia models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PowerLaw\nBlackBody","category":"page"},{"location":"models/#SpectralFitting.PowerLaw","page":"Models","title":"SpectralFitting.PowerLaw","text":"XS_PowerLaw(K, a)\n\nK\nNormalisation. Default: FitParam(1.0)\na\nPhoton index. Default: FitParam(0.5)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.BlackBody","page":"Models","title":"SpectralFitting.BlackBody","text":"XS_BlackBody(K, T)\n\nK\nNormalisation. Default: FitParam(1.0)\nkT\nTemperature (keV). Default: FitParam(2.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#XSPEC-models","page":"Models","title":"XSPEC models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"XS_PowerLaw\nXS_BlackBody\nXS_BremsStrahlung\nXS_Laor\nXS_DiskLine\nXS_PhotoelectricAbsorption\nXS_WarmAbsorption\nXS_CalculateFlux","category":"page"},{"location":"models/#SpectralFitting.XS_PowerLaw","page":"Models","title":"SpectralFitting.XS_PowerLaw","text":"XS_PowerLaw(K, a)\n\nK\nNormalisation. Default: FitParam(1.0)\na\nPhoton index. Default: FitParam(0.5)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_BlackBody","page":"Models","title":"SpectralFitting.XS_BlackBody","text":"XS_BlackBody(K, T)\n\nK\nNormalisation. Default: FitParam(1.0)\nT\nTemperature (keV). Default: FitParam(3.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_BremsStrahlung","page":"Models","title":"SpectralFitting.XS_BremsStrahlung","text":"XS_BremsStrahlung(K, T)\n\nK\nNormalisation. Default: FitParam(1.0)\nT\nPlasma temperature (keV). Default: FitParam(7.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_Laor","page":"Models","title":"SpectralFitting.XS_Laor","text":"XS_Laor(K, lineE, a, inner_r, outer_r, incl)\n\nK\nNormalisation. Default: FitParam(1.0)\nlineE\nRest frame line energy (keV). Default: FitParam(6.4)\na\nPower law dependence of emissitivy. Scales R⁻ᵅ. Default: FrozenFitParam(3.0)\ninner_r\nInner radius of the accretion disk (GM/c). Default: FrozenFitParam(1.235)\nouter_r\nOuter radius of the accretion disk (GM/c). Default: FrozenFitParam(400.0)\nincl\nDisk inclination angle to line of sight (degrees, 0 is pole on). Default: FitParam(30.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_DiskLine","page":"Models","title":"SpectralFitting.XS_DiskLine","text":"XS_DiskLine(K, lineE, β, inner_r, outer_r, incl)\n\nK\nNormalisation. Default: FitParam(1.0)\nlineE\nRest frame line energy (keV). Default: FitParam(6.7)\nβ\nPower law dependence of emissitivy. If < 10, scales Rᵅ. Default: FrozenFitParam(-2.0)\ninner_r\nInner radius of the accretion disk (GM/c). Default: FrozenFitParam(10.0)\nouter_r\nOuter radius of the accretion disk (GM/c). Default: FrozenFitParam(1000.0)\nincl\nDisk inclination angle to line of sight (degrees, 0 is pole on). Default: FitParam(30.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_PhotoelectricAbsorption","page":"Models","title":"SpectralFitting.XS_PhotoelectricAbsorption","text":"XS_PhotoelectricAbsorption(ηH)\n\nηH\nEquivalent hydrogen column (units of 10²² atoms per cm⁻²). Default: FitParam(1.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_WarmAbsorption","page":"Models","title":"SpectralFitting.XS_WarmAbsorption","text":"XS_WarmAbsorption(ηH, Ew)\n\nηH\nEquivalent hydrogen column (units of 10²² atoms per cm⁻²). Default: FitParam(1.0)\nEw\nWindow energy (keV). Default: FitParam(1.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_CalculateFlux","page":"Models","title":"SpectralFitting.XS_CalculateFlux","text":"XS_CalculateFlux(E_min, E_max, lg10Flux)\n\nE_min\nMinimum energy. Default: FrozenFitParam(0.2)\nE_max\nMaximum energy. Default: FrozenFitParam(2.0)\nlg10Flux\nlog (base 10) flux in erg / cm^2 / s Default: FitParam(-10.0, lowerlimit = -Inf, upperlimit = 0.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#Wrapping-new-XSPEC-models","page":"Models","title":"Wrapping new XSPEC models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"SpectralFitting exports a helpful macro to facilitate wrapping additional XSPEC models.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"@xspecmodel","category":"page"},{"location":"models/#SpectralFitting.@xspecmodel","page":"Models","title":"SpectralFitting.@xspecmodel","text":"@xspecmodel model_kind, func_name, model\n\nUsed to wrap additional XSPEC models, generating the needed AbstractSpectralModel implementation.\n\nExamples\n\n@xspecmodel Additive :C_powerlaw struct XS_PowerLaw{F1,F2}\n    \"Normalisation.\"\n    K::F1 = FitParam(1.0)\n    \"Photon index.\"\n    a::F2 = FitParam(0.5)\nend\n\nWe define a new structure XS_PowerLaw with two parameters, but since the model is Additive, only a single parameter (a) is passed to the XSPEC function. The function we bind to this model is :C_powerlaw from the XSPEC C wrappers.\n\nThe macro will, in this case, generate the following functions\n\nmodelkind(::Type{<:XS_PowerLaw})\nimplementation(::Type{<:XS_PowerLaw})\ninvoke!(::Type{<:XS_PowerLaw})\n\n\n\n\n\n","category":"macro"},{"location":"models/#Other-models","page":"Models","title":"Other models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"CompositeSpectralModel\n\nSurrogateSpectralModel\nwrap_model_as_objective\nmake_surrogate_function\noptimize_accuracy!","category":"page"},{"location":"models/#SpectralFitting.SurrogateSpectralModel","page":"Models","title":"SpectralFitting.SurrogateSpectralModel","text":"SurrogateSpectralModel <: AbstractSpectralModel\nSurrogateSpectralModel(modelkind, surrogate, params, params_symbols)\n\nUsed to wrap a surrogate function into an AbstractSpectralModel.\n\nExample\n\nCreating a surrogate function for XS_PhotoelectricAbsorption using wrap_model_as_objective and make_surrogate_function.\n\nusing SpectralFitting\nusing Surrogates\n\nmodel = XS_PhotoelectricAbsorption()\nobjsampler = wrap_model_as_objective(model)\n\n# upper and lower bounds on energy and ηH\nlb = (0.1, 1e-3)\nub = (30.0, 30.0)\n\n# build surrogate function\nsurrogate = make_surrogate_function(model, s_lb, s_ub)\n\n# create surrogate model\nsm = SurrogateSpectralModel(\n    Multiplicative(),\n    surrogate,\n    (FitParam(1.0),),\n    (:ηH,)\n)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.wrap_model_as_objective","page":"Models","title":"SpectralFitting.wrap_model_as_objective","text":"wrap_model_as_objective(model::AbstractSpectralModel; ΔE = 1e-1)\nwrap_model_as_objective(M::Type{<:AbstractSpectralModel}; ΔE = 1e-1)\n\nWrap a spectral model into an objective function for building/optimizing a surrogate model. Returns an anonymous function taking the tuple (E, params...) as the argument, and returning a single flux value.\n\n\n\n\n\n","category":"function"},{"location":"models/#SpectralFitting.make_surrogate_function","page":"Models","title":"SpectralFitting.make_surrogate_function","text":"make_surrogate_function(\n    model::M,\n    lowerbounds::T,\n    upperbounds::T;\n    optimization_samples = 200,\n    seed_samples = 50,\n    S::Type = RadialBasis,\n    sample_type = SobolSample(),\n    verbose = false,\n)\n\nCreates and optimizes a surrogate model of type S for model, using wrap_model_as_objective and  optimize_accuracy! for optimization_samples iterations. Model is initially seeded with seed_samples points prior to optimization.\n\nnote: Note\nAdditive models integrate energies to calculate flux, which surrogate models are currently not capable of. Results for Additive models likely to be inaccurate. This will be patched in a future version.\n\n\n\n\n\n","category":"function"},{"location":"models/#SpectralFitting.optimize_accuracy!","page":"Models","title":"SpectralFitting.optimize_accuracy!","text":"optimize_accuracy!(\n    surr::AbstractSurrogate,\n    obj::Function,\n    lb,\n    ub;\n    sample_type::SamplingAlgorithm = SobolSample(),\n    maxiters = 200,\n    N_truth = 5000,\n    verbose = false,\n)\n\nImprove accuracy (faithfullness) of the surrogate model in recreating the objective function.\n\nSamples a new space of N_truth points between lb and ub, and calculates the objective function obj at each. Finds the point with largest MSE between surrogate and objective, and adds the point to the surrogate pool. Repeats maxiters times, adding maxiters points to surrogate model.\n\nOptionally print to stdout the MSE and iteration count with verbose = true.\n\nNote that upper- and lower-bounds should be in the form (E, params...), where E is a single energy and params are the model parameters.\n\n\n\n\n\n","category":"function"},{"location":"#SpectralFitting.jl-Documentation","page":"Home","title":"SpectralFitting.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast and flexible spectral fitting in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting.jl is a package for defining and using spectral models, with a number of utilities to make model composition easy and invocation fast. SpectralFitting wraps LibXSPEC_jll.jl to expose the library of models from HEASoft XSPEC, and provides helper functions for operating with spectral data from a number of different missions. The package natively uses LsqFit.jl to fit parameters using the Levenberg-Marquardt algorithm, but makes it easy to use Optim.jl for more specialized fitting algorithms, or Turing.jl for Bayesian inference and MCMC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting is designed to be extended, such that new models are simple to create, and new dataset processing pipelines for different missions are brief to define. Where performance is key, SpectralFitting helps you define fast and AD-compatible surrogates of spectral models using Surrogates.jl, and embed them in the model composition algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, install LibXSPEC_jll and SpectralFitting:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/astro-group-bristol/LibXSPEC_jll.jl\")\nPkg.add(url = \"https://github.com/fjebaker/SpectralFitting.jl\")\n\nusing SpectralFitting\n# ....","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"}]
}
