var documenterSearchIndex = {"docs":
[{"location":"models/surrogate-models/#Surrogate-models","page":"Surrogate models","title":"Surrogate models","text":"","category":"section"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Surrogate models allow you to create fast or memory efficient approximations of model components, or assist in optimizing some objective function directly. SpectralFitting uses the Surrogates.jl library of models, that yields pure-Julia surrogate models. Consequently, surrogate models also permit use of automatic differentiation in fitting, and are therefore powerful tools for improving fitting performance.","category":"page"},{"location":"models/surrogate-models/#Surrogates-overview","page":"Surrogate models","title":"Surrogates overview","text":"","category":"section"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"warning: Warning\nThe surrogate model optimization does not work well for most XSPEC models currently. This is being actively developed.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Any function may be wrapped as a surrogate model using the SurrogateSpectralModel type.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"SurrogateSpectralModel","category":"page"},{"location":"models/surrogate-models/#SpectralFitting.SurrogateSpectralModel","page":"Surrogate models","title":"SpectralFitting.SurrogateSpectralModel","text":"SurrogateSpectralModel <: AbstractSpectralModel\nSurrogateSpectralModel(modelkind, surrogate, params, params_symbols)\n\nUsed to wrap a surrogate function into an AbstractSpectralModel.\n\nExample\n\nCreating a surrogate function using make_surrogate_harness:\n\n# build and optimize a surrogate model\nsurrogate = make_surrogate_harness(model, lower_bounds, upper_bounds)\n\n# create surrogate spectral model\nsm = SurrogateSpectralModel(\n    Multiplicative(),\n    surrogate,\n    (FitParam(1.0),),\n    (:ηH,)\n)\n\nThe lower_bounds and upper_bounds must be tuples in the form (E, params...), where E denotes the bounds on the energy range to train over.\n\n\n\n\n\n","category":"type"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"To facilitate easy surrogate builds, SpectralFitting exports a number of utility functions.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"make_surrogate_harness\noptimize_accuracy!","category":"page"},{"location":"models/surrogate-models/#SpectralFitting.make_surrogate_harness","page":"Surrogate models","title":"SpectralFitting.make_surrogate_harness","text":"make_surrogate_harness(\n    model::M,\n    lowerbounds::T,\n    upperbounds::T;\n    optimization_samples = 200,\n    seed_samples = 50,\n    S::Type = RadialBasis,\n    sample_type = SobolSample(),\n    verbose = false,\n)\n\nCreates and optimizes a surrogate model of type S for model, using wrap_model_as_objective and  optimize_accuracy! for optimization_samples iterations. Model is initially seeded with seed_samples points prior to optimization.\n\nwarning: Warning\nAdditive models integrate energies to calculate flux, which surrogate models are currently not capable of. Results for Additive models likely to be inaccurate. This will be patched in a future version.\n\n\n\n\n\n","category":"function"},{"location":"models/surrogate-models/#SpectralFitting.optimize_accuracy!","page":"Surrogate models","title":"SpectralFitting.optimize_accuracy!","text":"optimize_accuracy!(\n    surr::AbstractSurrogate,\n    obj::Function,\n    lb,\n    ub;\n    sample_type::SamplingAlgorithm = SobolSample(),\n    maxiters = 200,\n    N_truth = 5000,\n    verbose = false,\n)\n\nImprove accuracy (faithfullness) of the surrogate model in recreating the objective function.\n\nSamples a new space of N_truth points between lb and ub, and calculates the objective function obj at each. Finds the point with largest MSE between surrogate and objective, and adds the point to the surrogate pool. Repeats maxiters times, adding maxiters points to surrogate model.\n\nOptionally print to stdout the MSE and iteration count with verbose = true.\n\nNote that upper- and lower-bounds should be in the form (E, params...), where E is a single energy and params are the model parameters.\n\n\n\n\n\n","category":"function"},{"location":"models/surrogate-models/#Creating-a-surrogate-for-XS_PhotoelectricAbsorption","page":"Surrogate models","title":"Creating a surrogate for XS_PhotoelectricAbsorption","text":"","category":"section"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Before we start, let us discuss a number of benefits the use of surrogate models may bring us:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"SurrogateSpectralModel permit use of automatic differentiation.\nSurrogate models may be allocation-free depending on setup, whereas XSPEC wrappers will always have to allocate for type-conversions.\nSurrogate models may be considerably faster, especially for table models.\nSurrogate models are shareable (see Sharing surrogate models), and are tunable in size.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"XS_PhotoelectricAbsorption is an XSPEC model that is wrapped by a thin C-wrapper into Julia. The implementation of this model is a number of Fortran routines from the late 90s, including a tabulation of ~3000 lines of data that has been copied directly into the Fortran source code.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"The performance of this model represents its complexity.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using SpectralFitting, XSPECModels\n\nenergy = collect(range(0.1, 20.0, 200))\nmodel = XS_PhotoelectricAbsorption()\n\nflux = similar(energy)[1:end-1]","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Benchmarking with BenchmarkTools.jl:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using BenchmarkTools\n@benchmark invokemodel!($flux, $energy, $model)","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"The surrogate we'll construct will have to be tailored a little to the data we wish to fit, as we need to specify the parameter ranges our surrogate should learn. For example, we might be interested in energies between 01 and 20 keV (expressed in our domain), with equivalent hydrogen column etaH anywhere between 10^-3 and 30. We specify the parameter bounds using tuples:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"lower_bounds = (1e-3,)\nupper_bounds = (30.0,)\nnothing # hide","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"note: Note\nThe first index is always the energy bounds, and the subsequent indices are the parameters in the same order they are defined in the model structure.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Next, we use make_surrogate_harness to build and optimize a surrogate function for our model. By default, the surrogate uses linear radial basis functions, and seeds the coefficients with a number of seed points. This function then improves the accuracy of the model using optimize_accuracy!, until a maximal number of iterations has been reached.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"For illustration purposes, we'll omit the accuracy improving step, and perform this ourselves. We can do this by setting optimization_samples = 0 in the keyword arguments:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using Surrogates\n\nharness = make_surrogate_harness(\n    (x, y) -> RadialBasis(x, y, lower_bounds, upper_bounds),\n    energy,\n    model,\n    lower_bounds,\n    upper_bounds;\n    # default is 50, but to illustrate the training behaviour we'll set this low\n    seed_samples = 2,\n)\n\n# number of points the surrogate has been trained on\nlength(harness.surrogate.x)","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can examine how well our surrogate reconstructs the model for a given test parameter:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using Plots\n# random test value\nηh_test = 22.9\n\nmodel.ηH.value = ηh_test\nf = invokemodel(energy, model)\n\nf̂ = harness.surrogate([ηh_test])\n\np = plot(energy[1:end-1], f, label=\"model\", legend=:bottomright, xlabel=\"E (keV)\") # hide\nplot!(energy[1:end-1], f̂, label=\"surr\") # hide\np # hide","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now we'll use optimize_accuracy! to improve the faithfulness of our surrogate. This requires making use of wrap_model_as_objective as a little wrapper around our model:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"optimize_accuracy!(harness; maxiters=50)\n\nlength(harness.surrogate.x)","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can plot the surrogate model again and see the improvement.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"new_f̂ = harness.surrogate([ηh_test])\nplot!(energy[1:end-1], new_f̂, label=\"surr+\") # hide\np # hide","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Tight. We can also inspect the memory footprint of our model:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"# in bytes\nBase.summarysize(harness) ","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"This may be reduced by lowering maxiters in optimize_accuracy! at the cost of decreasing faithfulness. However, compare this to the Fortran tabulated source file in the XSPEC source code, which is approximately 224 Kb. The surrogate model with all it's training data is of the same order.","category":"page"},{"location":"models/surrogate-models/#Using-a-surrogate-spectral-model","page":"Surrogate models","title":"Using a surrogate spectral model","text":"","category":"section"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now that we have the surrogate model, we use SurrogateSpectralModel to wrap it into an AbstractSpectralModel. The constructor also needs to know the model kind, have a copy of the model parameters, and know which symbols to represent the parameters with.","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"sm = make_model(harness)","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can now use the familiar API and attempt to benchmark the performance:","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"@benchmark invokemodel!($flux, $energy, $sm)","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Comparing this to the initial benchmark of XS_PhotoelectricAbsorption, we see about a significant speedup, with no allocations, and this surrogate model is now automatic differentiation ready.","category":"page"},{"location":"models/surrogate-models/#Evaluating-the-model","page":"Surrogate models","title":"Evaluating the model","text":"","category":"section"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"p_range = collect(range(1.0, 30.0))\n\nfluxes_vecs = map(p_range) do p\n    model.ηH.value = p\n    f = invokemodel(energy, model)\nend\nfluxes_mat = reduce(hcat, fluxes_vecs)\n\nsurface(p_range, energy[1:end-1], fluxes_mat, xlabel = \"ηH\", ylabel = \"E\", zlabel = \"f\", title = \"Model\")","category":"page"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"s_fluxes_vecs = map(p_range) do p\n    sm.params[1].value = p\n    display(sm)\n    f = invokemodel(energy, sm)\nend\ns_fluxes_mat = reduce(hcat, s_fluxes_vecs)\n\nsurface(p_range, energy[1:end-1], s_fluxes_mat, xlabel = \"ηH\", ylabel = \"E\", zlabel = \"f\", title = \"Surrogate\")","category":"page"},{"location":"models/surrogate-models/#Sharing-surrogate-models","page":"Surrogate models","title":"Sharing surrogate models","text":"","category":"section"},{"location":"models/surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"To export and import surrogate models, JLD2.jl is recommended.","category":"page"},{"location":"models/models/#Model-index","page":"Model index","title":"Model index","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"Models wrapped from XSPEC implementations are prefixed with XS_*, whereas pure-Julia models are simply named, e.g. XS_PowerLaw in XSPEC vs PowerLaw in Julia.","category":"page"},{"location":"models/models/","page":"Model index","title":"Model index","text":"The available models are","category":"page"},{"location":"models/models/","page":"Model index","title":"Model index","text":"Pages = [\"models.md\"]\nOrder = [:type]","category":"page"},{"location":"models/models/#Julia-models","page":"Model index","title":"Julia models","text":"","category":"section"},{"location":"models/models/#Additive","page":"Model index","title":"Additive","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"PowerLaw\nBlackBody\nGaussianLine\nDeltaLine","category":"page"},{"location":"models/models/#SpectralFitting.PowerLaw","page":"Model index","title":"SpectralFitting.PowerLaw","text":"PowerLaw\n\nK: Normalisation.\na: Photon index.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, PowerLaw())\n\n                        PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.BlackBody","page":"Model index","title":"SpectralFitting.BlackBody","text":"BlackBody\n\nK: Normalisation.\nkT: Temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BlackBody())\n\n                        BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │     :'      '':.                       │\n       │   .'           ':.                     │\n       │  .:               '..                  │\n       │  :                  ':.                │\n       │ .'                     ':..            │\n       │ :                         ''...        │\n       │:                              '''....  │\n     0 │:                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.GaussianLine","page":"Model index","title":"SpectralFitting.GaussianLine","text":"GaussianLine\n\nK: Normalisation.\nμ: Mean\nσ: Standard deviation\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, GuassianLine())\n\n                       GaussianLine                \n        ┌────────────────────────────────────────┐ \n   0.09 │                                        │ \n        │            ..                          │ \n        │           .':                          │ \n        │           : :                          │ \n        │           : '.                         │ \n        │          .'  :                         │ \n        │          :   :                         │ \n        │          :   :                         │ \n        │          :   '.                        │ \n        │         :     :                        │ \n        │         :     :                        │ \n        │         :     :                        │ \n        │        .'      :                       │ \n        │        :       '.                      │ \n      0 │.......:         :......................│ \n        └────────────────────────────────────────┘ \n         0                                     20  \n                          E (keV)                  \n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.DeltaLine","page":"Model index","title":"SpectralFitting.DeltaLine","text":"DeltaLine\n\n_width\nK: Normalisation.\nE: Energy at which the delta function spikes.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, DeltaLine())\n\n                        DeltaLine                 \n       ┌────────────────────────────────────────┐ \n   0.4 │         .                              │ \n       │         :                              │ \n       │         :                              │ \n       │         :                              │ \n       │         :                              │ \n       │         :                              │ \n       │         ::                             │ \n       │         ::                             │ \n       │         ::                             │ \n       │         ::                             │ \n       │         ::                             │ \n       │         ::                             │ \n       │         ::                             │ \n       │         ::                             │ \n     0 │.........::.............................│ \n       └────────────────────────────────────────┘ \n        0                                     20  \n                         E (keV)                 \n\nnote: Note\nThe DeltaLine model is not a true delta function, as this would be extremely difficult to define in a numerical model that needs to be able to propagate gradients. Instead, it is a very narrow GaussianLine model.\n\n\n\n\n\n","category":"type"},{"location":"models/models/#Multiplicative","page":"Model index","title":"Multiplicative","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"PhotoelectricAbsorption","category":"page"},{"location":"models/models/#SpectralFitting.PhotoelectricAbsorption","page":"Model index","title":"SpectralFitting.PhotoelectricAbsorption","text":"PhotoelectricAbsorption\n\ntable\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\n\n\n\n\n\n","category":"type"},{"location":"models/models/#Convolutional","page":"Model index","title":"Convolutional","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"Log10Flux","category":"page"},{"location":"models/models/#SpectralFitting.Log10Flux","page":"Model index","title":"SpectralFitting.Log10Flux","text":"Log10Flux\n\nUsed to measure the (log) flux of the models it is applied to. Note that the additive components must have their normalisations frozen for this model to work properly.\n\nE_min\nE_max\nlog10Flux\n\nExample\n\nmodel = PowerLaw()\nmodel.K.frozen = true\n\nflux_model = Log10Flux()(model)\n\n\n\n\n\n","category":"type"},{"location":"models/models/#Wrappers","page":"Model index","title":"Wrappers","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"AutoCache\nAsConvolution","category":"page"},{"location":"models/models/#SpectralFitting.AutoCache","page":"Model index","title":"SpectralFitting.AutoCache","text":"AutoCache\n\nUsed to automatically create a cache of another model, to avoid re-evaluating the model if the next parameters are close to the previous parameters. The intended use is for fitting expensive models which.\n\nExample\n\nmodel = PhotoelectricAbsorption() * AutoCache(PowerLaw())\n\nIn the above model, the PowerLaw component will be augmented with the caching behaviour.\n\n\n\n\n\n","category":"type"},{"location":"models/models/#SpectralFitting.AsConvolution","page":"Model index","title":"SpectralFitting.AsConvolution","text":"AsConvolution\n\nTurn an additive model into a convolutional model.\n\nExample\n\nconvolution_model = AsConvolution(GaussianLine())\n\nThe above model will now convolve the GaussianLine model onto whatever it is applied to.\n\n\n\n\n\n","category":"type"},{"location":"models/models/#Utility","page":"Model index","title":"Utility","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"SpectralFitting.register_model_data\nSpectralFitting.finite_diff_kernel!\nwrap_model_as_objective","category":"page"},{"location":"models/models/#SpectralFitting.register_model_data","page":"Model index","title":"SpectralFitting.register_model_data","text":"SpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, model_data::ModelDataInfo...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, remote_and_local::Tuple{String,String}...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, filenames::String...)\nSpectralFitting.register_model_data(s::Symbol, filenames::String...)\n\nRegister filenames as model data associated with the model given by type M or symbol s. This function does not download any files, but rather adds the relevant filenames to a lookup which SpectralFitting.download_model_data consults when invoked, and consequently model data is only downloaded when needed.\n\nnote: Note\nIt is good practice to use this method immediately after defining a new model with @xspecmodel to register any required datafiles from the HEASoft source code, and therefore keep relevant information together.\n\nExample\n\n# by type\nregister_model_data(XS_Laor, \"ari.mod\")\n# by symbol\nregister_model_data(:XS_KyrLine, \"KBHline01.fits\")\n\n\n\n\n\n","category":"function"},{"location":"models/models/#SpectralFitting.finite_diff_kernel!","page":"Model index","title":"SpectralFitting.finite_diff_kernel!","text":"finite_diff_kernel!(f::Function, flux, energy)\n\nCalculates the finite difference of the function f over the energy bin between the high and low bin edges, via\n\nc_i = f(E_itexthigh) - f(E_itextlow)\n\nsimilar to evaluating the limits of the integral between E_itexthigh and E_itextlow.\n\nThis utility function is primarily used for Additive models to ensure the flux per bin is normalised for the energy over the bin.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#SpectralFitting.wrap_model_as_objective","page":"Model index","title":"SpectralFitting.wrap_model_as_objective","text":"wrap_model_as_objective(model::AbstractSpectralModel; ΔE = 1e-1)\nwrap_model_as_objective(M::Type{<:AbstractSpectralModel}; ΔE = 1e-1)\n\nWrap a spectral model into an objective function for building/optimizing a surrogate model. Returns an anonymous function taking the tuple (E, params...) as the argument, and returning a single flux value.\n\n\n\n\n\n","category":"function"},{"location":"models/models/#Generating-model-fingerprints","page":"Model index","title":"Generating model fingerprints","text":"","category":"section"},{"location":"models/models/","page":"Model index","title":"Model index","text":"To generate the unicode plot to add as a fingerprint, we use a simple function:","category":"page"},{"location":"models/models/","page":"Model index","title":"Model index","text":"using SpectralFitting, UnicodePlots\n\nfunction plotmodel(energy, model)\n    flux = invokemodel(energy, model)\n    lineplot(\n        energy[1:end-1], \n        flux, \n        title=String(Base.typename(typeof(model)).name), \n        xlabel=\"E (keV)\", \n        canvas=DotCanvas\n    )\nend\n\n# e.g. for XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\nplotmodel(energy, PowerLaw())","category":"page"},{"location":"examples/examples/#Spectral-fitting-examples","page":"Diverse examples","title":"Spectral fitting examples","text":"","category":"section"},{"location":"examples/examples/","page":"Diverse examples","title":"Diverse examples","text":"using SpectralFitting\nusing Plots\nENV[\"GKSwstype\"]=\"nul\"\nPlots.default(show=false)","category":"page"},{"location":"examples/examples/","page":"Diverse examples","title":"Diverse examples","text":"Below are a number of examples illustrating how this package may be used.","category":"page"},{"location":"examples/examples/#Using-the-model-library","page":"Diverse examples","title":"Using the model library","text":"","category":"section"},{"location":"examples/examples/","page":"Diverse examples","title":"Diverse examples","text":"The model library details a model algebra (see AbstractSpectralModelKind) for composing models together. An example use of this may be to construct a complex model from a series of simpler models, and invoke the models on a given energy grid:","category":"page"},{"location":"examples/examples/","page":"Diverse examples","title":"Diverse examples","text":"using SpectralFitting\nusing Plots \n\nmodel = PhotoelectricAbsorption() * (PowerLaw() + BlackBody()) \n\n# define energy grid\nenergy = collect(range(0.1, 12.0, 100))\n\nflux = invokemodel(energy, model)\n\nplot(energy[1:end-1], flux)","category":"page"},{"location":"examples/examples/","page":"Diverse examples","title":"Diverse examples","text":"Note this energy grid may be arbitrarily spaced, but, like XSPEC, assumes the bins are contiguous, i.e. that the high energy limit of one bin is the low energy limit of the next.","category":"page"},{"location":"examples/examples/","page":"Diverse examples","title":"Diverse examples","text":"The full model library of available models is listed in Model index.","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/#Parameter-binding","page":"Parameters","title":"Parameter binding","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"When performing a fit, it is desireable to bind certain parameters together. This ensures that they will have the same value; for example, if you were fitting two simultaneous datasets with two PowerLaw models, you may want to have different normalisations of the model components, but enforce the power law index to be the same. To achieve this, SpectralFitting has the bind! function that applies to your FittingProblem.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"bind!","category":"page"},{"location":"parameters/#SpectralFitting.bind!","page":"Parameters","title":"SpectralFitting.bind!","text":"bind!(prob::FittingProblem, pairs::Pair{Int,Symbol}...)\nbind!(prob::FittingProblem, symbols::Symbol...)\n\nBind parameters together within a FittingProblem. Parameters bound together will be mandated to have exact same value during the fit.\n\nThe binding may either be a single symbol that is present in all models in the fitting problem, or a series of pairs Int => Symbol which index the specific model and parameters to bind together. All bindings specified in a single call to bind! will be bound together. Multiple bindings are possible with repeated call to bind!.\n\nBind model 1's K_1 parameter to model 2's K_3:\n\nbind!(prob, 1 => :K_1, 2 => :K_3)\n\nBind model 3's K_2 parameter to model4's :L_1 and model 6's a_3:\n\nbind!(prob, 3 => :K_2, 4 => :L_1, 6 => :a_3)\n\nBind the K_1 parameter across all the models:\n\nbind!(prob, :K_1)\n\nExamples\n\nConsider the following two models\n\nmodel1 = PhotoelectricAbsorption() * (BlackBody() + PowerLaw())\nmodel2 = PhotoelectricAbsorption() * (PowerLaw() + PowerLaw())\n\nprob = FittingProblem(model1 => data1, model2 => data2)\n\n# bind the power law indices in the two models\nbind!(prob, :a_1)\n\n# bind the normalisation of powerlaws in the 2nd model:\nbind!(prob, 2 => :K_1, 2 => :K_2)\n\nnote: Note\nOnly free parameters can be bound together.\n\n\n\n\n\n","category":"function"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"note: Note\nBindings are treated not as specific to the model but specific to the FittingProblem. This is because you may want to use the same model for multiple different datasets, and have slightly different binding requirements for each one (e.g. depending on the instruments you are using). If you do need the same binding applied to two different problems, you can do that withappend!(prob1.bindings, prob2.bindings)Caution however, this will only make sense if you are using precisely the same model in both problems.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Let's try it out. We'll generate some arbitrary powerlaw spectra with different normalisations and fit them simultaneously.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"using SpectralFitting, Plots\n\nenergy = collect(range(0.1, 10.0, 100))\n\n# two different models with different normalisations\nmodel1 = PowerLaw(K = FitParam(100.0), a = FitParam(1.2))\nmodel2 = PowerLaw(K = FitParam(300.0), a = FitParam(1.22))\n\ndata1 = simulate(energy, model1, var = 1e-3)\ndata2 = simulate(energy, model2, var = 1e-3)\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Now we want to fit a single powerlaw model to both of these spectra simultaneously, but with the powerlaw index fixed to be the same in both models.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"model = PowerLaw()\nprob = FittingProblem(model => data1, model => data2)\n\nbind!(prob, :a)\nprob","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"We can get a better look at our model configuration by using the details method:","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"details(prob)","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"In this printout we see that the a parameter of Model 2 is bound to the a parameter of Model 1.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"result = fit(prob, LevenbergMarquadt())\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\nplot!(result[1])\nplot!(result[2])","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Note that these fits are not perfect, because the underlying data have subtly different power law indices, but our fit is required to enforce the models to have the same value. If we release this requirement, the fit will be better, but the models will be entirely independent.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"prob = FittingProblem(model => data1, model => data2)\n\nresult = SpectralFitting.fit(prob, LevenbergMarquadt())\n\nplot(data1, xscale = :log10, yscale = :log10)\nplot!(data2, xscale = :log10, yscale = :log10)\nplot!(result[1])\nplot!(result[2])","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"CurrentModule = XSPECModels","category":"page"},{"location":"models/xspec-models/#XSPEC-models","page":"XSPEC models","title":"XSPEC models","text":"","category":"section"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"SpectralFitting can vendor the XSPEC model library through the utility package XSPECModels.jl. You can install this package directly from the University of Bristol's AstroRegistry:","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"pkg> registry add https://github.com/astro-group-bristol/AstroRegistry\npkg> add XSPECModels","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"Using the package is straight forward once installed:","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"using SpectralFitting, XSPECModels","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"note: Note\nThe convention is that models that have are imported from XSPEC or have XSPEC ABI are prefixed with XS_ in their name. For example, the XSPEC equivalent of PowerLaw is XS_PowerLaw.","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"The XSPEC models are wrapped into SpectralFitting models using the [@xspecmodel] macro. If a model you require is not already wrapped, this macro will make that easy to do. Please consider upstreaming your wrapper via a PR to the SpectralFitting GitHub repository.","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"@xspecmodel","category":"page"},{"location":"models/xspec-models/#XSPECModels.@xspecmodel","page":"XSPEC models","title":"XSPECModels.@xspecmodel","text":"@xspecmodel [type=Float64] [ff_call_site] model\n\nUsed to wrap additional XSPEC models, generating the needed AbstractSpectralModel implementation.\n\nThe type keyword specifies the underlying type to coerce input and output arrays to, as different implementations may have incompatible number of bits. The ff_call_site is the foreign fuction call site, which is the first argument to ccall, and follows the same conventions. The model is a struct, which must subtype AbstractSpectralModel.\n\nIf the callsite is not specified, the user must implement _unsafe_ffi_invoke!.\n\nExamples\n\n@xspecmodel :C_powerlaw struct XS_PowerLaw{T} <: AbstractSpectralModel{T, Additive}\n    \"Normalisation.\"\n    K::T\n    \"Photon index.\"\n    a::T\nend\n\n# constructor has default values\nfunction XS_PowerLaw(; K = FitParam(1.0), a = FitParam(1.0))\n    XS_PowerLaw{typeof(K)}(K, a)\nend\n\nWe define a new structure XS_PowerLaw with two parameters, but since the model is Additive, only a single parameter (a) is passed to the XSPEC function. The function we bind to this model is :C_powerlaw from the XSPEC C wrappers.\n\nThe macro will then generate the following functions\n\nimplementation\ninvoke!\n_safe_ffi_invoke!\n\nIf a callsite was specified, it will also generate:\n\n_unsafe_ffi_invoke!\n\n\n\n\n\n","category":"macro"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"XSPEC models frequently have tabular data dependencies, without which the models fail to invoke (see Model data availability). If the data files are known but not present, the XSPEC models will throw an error with instructions for downloading the missing data. If the data files are unknown, Julia may crash catastrophically. If this is the case, often a single line will be printed with the LibXSPEC error, specifying the name of the missing source file. This can be registered as a data dependency of a model using SpectralFitting.register_model_data.","category":"page"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"The first time any XSPEC model is invoked, SpectralFitting checks to see whether requisite data is needed, and whether the data is downloaded. Subsequent calls will hit a lookup cache instead to avoid run-time costs of performing this check.","category":"page"},{"location":"models/xspec-models/#Additive","page":"XSPEC models","title":"Additive","text":"","category":"section"},{"location":"models/xspec-models/","page":"XSPEC models","title":"XSPEC models","text":"XS_PowerLaw\nXS_BlackBody\nXS_BremsStrahlung\nXS_Gaussian\nXS_Laor\nXS_DiskLine\nXS_PhotoelectricAbsorption\nXS_WarmAbsorption\nXS_CalculateFlux\nXS_KerrDisk\nXS_KyrLine","category":"page"},{"location":"models/xspec-models/#XSPECModels.XS_PowerLaw","page":"XSPEC models","title":"XSPECModels.XS_PowerLaw","text":"XS_PowerLaw(K, a)\n\nK: Normalisation.\na: Photon index.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PowerLaw())\n\n                      XS_PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_BlackBody","page":"XSPEC models","title":"XSPECModels.XS_BlackBody","text":"XS_BlackBody(K, T)\n\nK: Normalisation.\nT: Temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BlackBody())\n\n                      XS_BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │    .:       ''.                        │\n       │   .'           ':.                     │\n       │   :              ''..                  │\n       │  :                  ':.                │\n       │ :                     '':.             │\n       │.:                         ''..         │\n       │:                              '':....  │\n     0 │'                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_BremsStrahlung","page":"XSPEC models","title":"XSPECModels.XS_BremsStrahlung","text":"XS_BremsStrahlung(K, T)\n\nK: Normalisation.\nT: Plasma temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BremsStrahlung())\n\n                  XS_BremsStrahlung\n     ┌────────────────────────────────────────┐\n   2 │                                        │\n     │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │'.                                      │\n     │ :                                      │\n   0 │  ':....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_Gaussian","page":"XSPEC models","title":"XSPECModels.XS_Gaussian","text":"XS_Gaussian(K, E, σ)\n\nK: Normalisation\nE: Line wavelength in Angstrom.\nσ: Line width in Angstrom.\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_Gaussian())\n\n                        XS_Gaussian\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │            .                           │\n        │           : :                          │\n        │           : :                          │\n        │           : '.                         │\n        │          .'  :                         │\n        │          :   :                         │\n        │          :   :                         │\n        │          :   '.                        │\n        │         :     :                        │\n        │         :     :                        │\n        │         :     :                        │\n        │        .'      :                       │\n        │        :       :                       │\n      0 │.......:         :......................│\n        └────────────────────────────────────────┘\n         0                                     20\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_Laor","page":"XSPEC models","title":"XSPECModels.XS_Laor","text":"XS_Laor(K, lineE, a, inner_r, outer_r, incl)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\na: Power law dependence of emissitivy. Scales R⁻ᵅ.\ninner_r: Inner radius of the accretion disk (GM/c).\nouter_r: Outer radius of the accretion disk (GM/c).\nθ: Disk inclination angle to line of sight (degrees, 0 is pole on).\n\nExample\n\nenergy = collect(range(0.1, 10.0, 100))\ninvokemodel(energy, XS_Laor())\n\n                          XS_Laor\n        ┌────────────────────────────────────────┐\n   0.06 │                                        │\n        │                                        │\n        │                         ::             │\n        │                         ::             │\n        │                        : :             │\n        │                       :  :             │\n        │                      :   :             │\n        │                     :'   :             │\n        │                   .:     :             │\n        │                  :'      :             │\n        │                .'        :             │\n        │              .:'         :             │\n        │            ..'           :             │\n        │          .:'              :            │\n      0 │.......:''                 :............│\n        └────────────────────────────────────────┘\n         0                                     10\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_DiskLine","page":"XSPEC models","title":"XSPECModels.XS_DiskLine","text":"XS_DiskLine(K, lineE, β, inner_r, outer_r, incl)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\nβ: Power law dependence of emissitivy. If < 10, scales Rᵅ.\ninner_r: Inner radius of the accretion disk (GM/c).\nouter_r: Outer radius of the accretion disk (GM/c).\nθ: Disk inclination angle to line of sight (degrees, 0 is pole on).\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_DiskLine())\n\n                        XS_DiskLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │                           .            │\n        │                           :            │\n        │                           ::           │\n        │                         . ::           │\n        │                         : ::           │\n        │                         :'':           │\n        │                        .'  :           │\n        │                        :    :          │\n        │                        :    :          │\n        │                       .'    :          │\n        │                       :     :          │\n        │                     .:      '.         │\n        │                   .:'        :         │\n      0 │...............:'''           :.........│\n        └────────────────────────────────────────┘\n         4                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_PhotoelectricAbsorption","page":"XSPEC models","title":"XSPECModels.XS_PhotoelectricAbsorption","text":"XS_PhotoelectricAbsorption(ηH)\n\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PhotoelectricAbsorption())\n\n             XS_PhotoelectricAbsorption\n     ┌────────────────────────────────────────┐\n   1 │       ...''''''''''''''''''''''''''''''│\n     │      .'                                │\n     │     :                                  │\n     │    :'                                  │\n     │    :                                   │\n     │   :                                    │\n     │   :                                    │\n     │   :                                    │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │ :                                      │\n   0 │.:                                      │\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_WarmAbsorption","page":"XSPEC models","title":"XSPECModels.XS_WarmAbsorption","text":"XS_WarmAbsorption(ηH, Ew)\n\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\nEw: Window energy (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_WarmAbsorption())\n\n                    XS_WarmAbsorption\n       ┌────────────────────────────────────────┐\n     1 │':      ...''':'''''''''''''''''''''''''│\n       │ :    .:'                               │\n       │ :   .'                                 │\n       │ :  .:                                  │\n       │ :  :                                   │\n       │ :  :                                   │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ ::                                     │\n       │ ::                                     │\n       │  :                                     │\n       │  :                                     │\n   0.2 │  :                                     │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_CalculateFlux","page":"XSPEC models","title":"XSPECModels.XS_CalculateFlux","text":"XS_CalculateFlux(E_min, E_max, lg10Flux)\n\nE_min: Minimum energy.\nE_max: Maximum energy.\nlog10Flux: log (base 10) flux in erg / cm^2 / s\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_KerrDisk","page":"XSPEC models","title":"XSPECModels.XS_KerrDisk","text":"XS_KerrDisk(K, lineE, index1, index2, break_r, a, θ, inner_r, outer_r)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\nindex1: Emissivity index for inner disk.\nindex2: Emissivity index for outer disk.\nbreak_r: Break radius seperating inner and outer disk (gᵣ).\na: Dimensionless black hole spin.\nθ: Disk inclination angle to line of sight (degrees).\ninner_r: Inner radius of the disk in units of rₘₛ.\nouter_r: Outer radius of the disk in units of rₘₛ.\nz: Redshift.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KerrDisk())\n\n                        XS_KerrDisk\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                .       │\n        │                               .:       │\n        │                              :::       │\n        │                            .:' '.      │\n        │                           .:    :      │\n        │                         ..'     :      │\n        │                         :'      :      │\n        │                       .'        :      │\n        │                     .:'         :      │\n        │                  .:''           :      │\n        │               .::'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/xspec-models/#XSPECModels.XS_KyrLine","page":"XSPEC models","title":"XSPECModels.XS_KyrLine","text":"XS_KyrLine(K, a, θ_obs, inner_r, ms_flag, outer_r, lineE, α, β, break_r, z, limb)\n\nK: Normalisation.\na: Dimensionless black hole spin.\nθ: Observer inclination (0 is on pole, degrees).\ninner_r: Inner radius of the disk in units of GM/c²\nms_flag: 0: integrate from rᵢₙ. 1: integrate from rₘₛ.\nouter_r: Outer radius of the disk in units of GM/c²\nlineE: Rest frame line energy (keV).\nα\nβ\nbreak_r: Break radius seperating inner and outer disk (GM/c²).\nz: Overall Doppler shift.\nlimb: 0: isotropic emission, 1: Laor's limb darkening, 2: Haard's limb brightening.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KyrLine())\n\n                        XS_KyrLine\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                :       │\n        │                                :.      │\n        │                              :.':      │\n        │                             :'  :      │\n        │                            :    :      │\n        │                          .'     :      │\n        │                        .:'      :      │\n        │                       .'        :      │\n        │                     .:          :      │\n        │                   .'            :      │\n        │                .:'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"transitioning-from-xspec/#Transitioning-from-XSPEC","page":"Transitioning from XSPEC","title":"Transitioning from XSPEC","text":"","category":"section"},{"location":"examples/optimizers/#Optimizer-galore","page":"Optimizer galore","title":"Optimizer galore","text":"","category":"section"},{"location":"examples/optimizers/","page":"Optimizer galore","title":"Optimizer galore","text":"Let's fit a spectrum:","category":"page"},{"location":"examples/optimizers/","page":"Optimizer galore","title":"Optimizer galore","text":"using SpectralFitting, Plots\n\nDATADIR = \"...\"\nDATADIR = length(get(ENV, \"CI\", \"\")) > 0 ? @__DIR__() * \"/../../ex-datadir\" : \"/home/lilith/Developer/jl/datasets/xspec/walkthrough\" # hide\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) \nnormalize!(data)\n\nmask_energies!(data, 1, 15)\n\n# a plotting utility\nmy_plot(data) = plot(\n    data, \n    xscale = :log10, \n    yscale = :log10,\n    ylims = (1e-3, 1.3)\n)\n\nmy_plot(data)","category":"page"},{"location":"examples/sherpa-example/#A-quick-guide-to-modelling-and-fitting-in-SpectralFitting.jl","page":"A quick guide","title":"A quick guide to modelling and fitting in SpectralFitting.jl","text":"","category":"section"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"This is SpectralFitting.jl version of A quick guide to modeling and fitting in Sherpa.","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"using SpectralFitting, Plots\nusing Random\nRandom.seed!(0)\n\nx = collect(range(-5, 5, 200))\n\nA_true = 3.0\npos_true = 1.3\nsigma_true = 0.8\nerr_true = 0.2\n\ny = @. A_true * exp(-(x - pos_true)^2 / (2 * sigma_true^2))\n\ny_noisy = y .+ (0.2 * randn(length(y)))\n\nscatter(x, y_noisy)","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"To make this into a fittable dataset, we observe that our layout is injective (i.e. length(x) == length(y)). This is subtly different from how the majority of spectral models are implemented, which usually assume some kind of binning (length(x) == length(y) + 1). Fortunately, SpectralFitting.jl can track this for us, and do various conversion to make the models work correctly for the data. We need only tell the package what our AbstractLayout is:","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"data = InjectiveData(x, y_noisy; name = \"example\")","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"The data prints the data card, which provides us some high level information about our data at a glance. We can plot the data trivially using one of the Plots.jl recipes","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"plot(data, markersize = 3)","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"Next we want to specify a model to fit to this data. Models that are prefixed with XS_ are models that are linked from the XSPEC model library, provided via LibXSPEC_jll. For a full list of the models, see Models index.","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"warning: Warning\nIt is advised to use the Julia implemented models. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see Why & how.","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"model = GaussianLine(μ = FitParam(0.0))","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"We can plot our model over the same domain range quite easily too:","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"plot(data.domain[1:end-1], invokemodel(data.domain, model))","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"Note that we've had to adjust the domain here. As stated before, most models are implemented for binned data, and therefore return one fewer bin than given.","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a FittingProblem:","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"prob = FittingProblem(model => data)","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"We fit problem then by calling fit:","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"result = fit(prob, LevenbergMarquadt())","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"The result card tells us a little bit about how successful the fit was. We further inspect the fit by overplotting result on the data:","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"plot(data, markersize = 3)\nplot!(result)","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"We can create a contour plot of the fit statistic by evaluating the result everywhere on the grid and measuring the statistic:","category":"page"},{"location":"examples/sherpa-example/","page":"A quick guide","title":"A quick guide","text":"amps = range(50, 200, 50)\ndevs = range(0.5, 1.2, 50)\n\nstats = [\n    measure(ChiSquared(), result, [a, result.u[2], d])\n    for d in devs, a in amps\n]\n\n# 1, 2, and 3 sigma contours\nlevels = [2.3, 4.61, 9.21]\ncontour(\n    amps, \n    devs, \n    stats .- result.χ2, \n    levels = levels, \n    xlabel = \"K\", \n    ylabel = \"σ\"\n)\nscatter!([result.u[1]], [result.u[3]])","category":"page"},{"location":"examples/sherpa-example/#Simultaneous-fits","page":"A quick guide","title":"Simultaneous fits","text":"","category":"section"},{"location":"models/composite-models/#Composite-models","page":"Composite models","title":"Composite models","text":"","category":"section"},{"location":"models/composite-models/","page":"Composite models","title":"Composite models","text":"The model algebra defined by the AbstractSpectralModelKind yields instances of CompositeModel, nested to various degrees. These composite models are designed to make as much information about the spectral model available at compile-time, such that rich and optimized generated functions may be assembled purely from the Julia types (see Why & how).","category":"page"},{"location":"models/composite-models/","page":"Composite models","title":"Composite models","text":"CompositeModel\nAbstractCompositeOperator\nAdditionOperator\nMultiplicationOperator\nConvolutionOperator\noperation_symbol","category":"page"},{"location":"models/composite-models/#SpectralFitting.CompositeModel","page":"Composite models","title":"SpectralFitting.CompositeModel","text":"CompositeModel{M1,M2,O} <: AbstractSpectralModel\nCompositeModel(left_model, right_model, op::AbstractCompositeOperator)\n\nType resulting from operations combining any number of AbstractSpectralModel via the model algebra defined from AbstractSpectralModelKind.\n\nEach operation binary operation in the model algebra is encoded in the parametric types of the CompositeModel, where the operation is given by an AbstractCompositeOperator. Composite models adopt the model kind of the right model, i.e. M2, and obey the model algebra accordingly.\n\nComposite models very rarely need to be constructed directly, and are instead obtained by regular model operations.\n\nExample\n\nmodel = PhotoelectricAbsorption() * (PowerLaw() + BlackBody())\ntypeof(model) <: CompositeModel # true\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.AbstractCompositeOperator","page":"Composite models","title":"SpectralFitting.AbstractCompositeOperator","text":"abstract type AbstractCompositeOperator\n\nSuperype of all composition operators. Used to implement the model algebra of AbstractSpectralModelKind through a trait system.\n\nThe Julia symbol corresponding to a given AbstractCompositeOperator may be obtained through operation_symbol.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.AdditionOperator","page":"Composite models","title":"SpectralFitting.AdditionOperator","text":"AdditionOperator <: AbstractCompositeOperator\nAdditionOperator()\n\nCorresponds to the :(+) symbol.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.MultiplicationOperator","page":"Composite models","title":"SpectralFitting.MultiplicationOperator","text":"MultiplicationOperator <: AbstractCompositeOperator\nMultiplicationOperator()\n\nCorresponds to the :(*) symbol.\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.ConvolutionOperator","page":"Composite models","title":"SpectralFitting.ConvolutionOperator","text":"ConvolutionOperator <: AbstractCompositeOperator\nConvolutionOperator()\n\nHas no corresponding symbol, since it invokes a function call C(A).\n\n\n\n\n\n","category":"type"},{"location":"models/composite-models/#SpectralFitting.operation_symbol","page":"Composite models","title":"SpectralFitting.operation_symbol","text":"operation_symbol(::AbstractCompositeOperator)\noperation_symbol(::Type{<:AbstractCompositeOperator})\n\nObtain the model symbol from a given AbstractCompositeOperator.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#Datasets","page":"Using datasets","title":"Datasets","text":"","category":"section"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"SpectralFitting.jl supports a wide variety of datasets, and makes it easy to wrap your own.","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"For spectral fitting specifics, the main dataset type is","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"SpectralData","category":"page"},{"location":"datasets/datasets/#SpectralFitting.SpectralData","page":"Using datasets","title":"SpectralFitting.SpectralData","text":"SpectralData{T} <: AbstractDataset\n\nA general spectral data structure, minimally with a Spectrum and ResponseMatrix. Optionally also includes the AncillaryResponse and a background Spectrum.\n\nMethods\n\nThe following methods are made available through the SpectralData:\n\nregroup!\nrestrict_domain!\nmask_energies!\ndrop_channels!\ndrop_bad_channels!\ndrop_negative_channels!\nnormalize!\nobjective_units\nspectrum_energy\nbin_widths\nsubtract_background!\nset_domain!\nerror_statistic\n\nConstructors\n\nThe available constructors are:\n\nSpectralData(paths::SpectralDataPaths; kwargs...)\n\nUsing SpectralDataPaths.\n\nIf the spectrum and repsonse matrix have already been loaded seperately, use\n\nSpectralData(\n    spectrum::Spectrum,\n    response::ResponseMatrix;\n    # try to match the domains of the response matrix to the data\n    match_domains = true,\n    background = nothing,\n    ancillary = nothing,\n)\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#Dataset-abstraction","page":"Using datasets","title":"Dataset abstraction","text":"","category":"section"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"Datasets must define a small API to make fitting possible. The picture to have in mind when considering the different domains is as follows: the model is trying to predict the objective. It does so by taking in input domain and maps it to some output domain.","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"That means make_output_domain and make_objective_domain correspond to the (XY) values of the data that the model is trying to fit, whilst the model is evaluated on the make_model_domain, which need not be the same as the output domain.","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"In other cases, the objective_transformer acts to transform the output of the model onto the output domain. ","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"Mathematically, expressing the output domain X, the model domain D, the model output M(D) and objective S, along with the transformer as T, then the relationship between the different domains is","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"hatS = T times M(D)","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"Both hatS and S are defined over X. The various fitting operations try to find model paramters that make hatS and S as close as possible.","category":"page"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"AbstractDataset\nmake_objective_variance\nmake_objective\nmake_domain_variance\nmake_model_domain\nmake_output_domain","category":"page"},{"location":"datasets/datasets/#SpectralFitting.AbstractDataset","page":"Using datasets","title":"SpectralFitting.AbstractDataset","text":"abstract type AbstractDataset\n\nAbstract type for use in fitting routines. High level representation of some underlying  data structures. \n\nFitting data is considered to have an objective and a domain. As the domain may be, for example, energy bins (high and low), or fourier frequencies (single value), the purpose of this abstraction is to provide some facility for translating between these representations for the models to fit with. This is done by checking that the AbstractLayout of the model and data are compatible, or at least have compatible translations.\n\nMust implement a minimal set of accessor methods. These are paired with objective and domain parlance. Note that these functions are prefixed with make_* and not get_* to represent that there may be allocations or work going into the translation. Usage of these functions should be sparse in the interest of performance.\n\nThe arrays returned by the make_* functions must correspond to the AbstractLayout specified by the caller.\n\nmake_objective_variance\nmake_objective\nmake_domain_variance\nmake_model_domain\nmake_ouput_domain\n\nAdditionally there is an objective transformer that transforms the output of the model onto the output domain:\n\nobjective_transformer\n\nFinally, to make all of the fitting for different statistical regimes work efficiently, datasets should inform which units are preferred to fit. They may also give the error statistics they prefer, and a label name primarily used to disambiguate:\n\npreferred_units\nerror_statistic\nmake_label\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.make_objective_variance","page":"Using datasets","title":"SpectralFitting.make_objective_variance","text":"make_objective_variance(layout::AbstractLayout, dataset::AbstractDataset)\n\nMake the variance vector associated with each objective point.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_objective","page":"Using datasets","title":"SpectralFitting.make_objective","text":"make_objective(layout::AbstractLayout, dataset::AbstractDataset)\n\nReturns the array used as the target for model fitting. The array must correspond to the data AbstractLayout specified by the layout parameter.\n\nIn as far as it can be guarunteed, the memory in the returned array will not be mutated by any fitting procedures.\n\nDomain for this objective should be returned by make_model_domain.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_domain_variance","page":"Using datasets","title":"SpectralFitting.make_domain_variance","text":"make_domain_variance(layout::AbstractLayout, dataset::AbstractDataset)\n\nMake the variance vector associated with the domain.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_model_domain","page":"Using datasets","title":"SpectralFitting.make_model_domain","text":"make_model_domain(layout::AbstractLayout, dataset::AbstractDataset)\n\nReturns the array used as the domain for the modelling. This is paired with make_domain_variance\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.make_output_domain","page":"Using datasets","title":"SpectralFitting.make_output_domain","text":"make_output_domain(layout::AbstractLayout, dataset::AbstractDataset)\n\nReturns the array used as the output domain. That is, in cases where the model input and output map to different domains, the input domain is said to be the model domain, the input domain is said to be the model domain. \n\nThe distinction is mainly used for the purposes of simulating data and for visualising data.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#Underlying-data-layouts","page":"Using datasets","title":"Underlying data layouts","text":"","category":"section"},{"location":"datasets/datasets/","page":"Using datasets","title":"Using datasets","text":"AbstractLayout\nOneToOne\nContiguouslyBinned\ncommon_support\npreferred_support\nsupports","category":"page"},{"location":"datasets/datasets/#SpectralFitting.AbstractLayout","page":"Using datasets","title":"SpectralFitting.AbstractLayout","text":"abstract type AbstractLayout end\n\nThe data layout primarily concerns the relationship between the objective and the domain. It is used to work out whether a model and a dataset are fittable, and if not, whether a translation in the output of the model to the domain of the model is possible.\n\nThe following methods may be used to interrogate support:\n\npreferred_support for inferring the preferred support of a model when multiple supports are possible.\ncommon_support to obtain the common support of two structures\n\nThe following method is also used to define the support of a model or dataset:\n\nsupports\n\nFor cases where unit information needs to be propagated, an AbstractLayout can also be used to ensure the units are compatible. To query the units of a layout, use\n\nsupport_units\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.OneToOne","page":"Using datasets","title":"SpectralFitting.OneToOne","text":"struct OneToOne <: AbstractLayout end\n\nIndicates there is a one-to-one (injective) correspondence between each input value and each output value. That is to say\n\nlength(objective) == length(domain)\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.ContiguouslyBinned","page":"Using datasets","title":"SpectralFitting.ContiguouslyBinned","text":"struct ContiguouslyBinned <: AbstractLayout end\n\nContiguously binned data layout means that the domain describes high and low bins, with the objective being the value in that bin. This means\n\nlength(objective) + 1== length(domain)\n\nNote that the contiguous qualifer is to mean there is no gaps in the bins, and that\n\nDelta E_i = E_i+1 - E_i\n\n\n\n\n\n","category":"type"},{"location":"datasets/datasets/#SpectralFitting.common_support","page":"Using datasets","title":"SpectralFitting.common_support","text":"common_support(x, y)\n\nFind the common AbstractLayout of x and y, following the ordering of preferred_support.\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.preferred_support","page":"Using datasets","title":"SpectralFitting.preferred_support","text":"preferred_support(x)\n\nGet the preferred AbstractLayout of x. If multiple supports are available,  the DEFAULT_SUPPORT_ORDERING is followed:\n\nDEFAULT_SUPPORT_ORDERING = (ContiguouslyBinned{Nothing}(nothing), OneToOne{Nothing}(nothing))\n\n\n\n\n\n","category":"function"},{"location":"datasets/datasets/#SpectralFitting.supports","page":"Using datasets","title":"SpectralFitting.supports","text":"supports(x::Type)\n\nUsed to define whether a given type has support for a specific AbstractLayout. Should return a tuple of the supported layouts. This method should be implemented to express new support, not the query method. \n\nTo query, there is\n\nsupports(layout::AbstractLayout, x)::Bool\n\nExample\n\nsupports(::Type{typeof(x)}) = (OneToOne(),)\n@assert supports(ContiguouslyBinned(), x) == false\n\n\n\n\n\n","category":"function"},{"location":"why-and-how/#Why-and-how","page":"Why & How","title":"Why & how","text":"","category":"section"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"SpectralFitting.jl is a package for fitting models to spectral data, similar to XSPEC, Sherpa or ISIS.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"The rationale for this package is to provide a unanimous interface for different model libraries, and to leverage advancements in the computional methods that are available in Julia, including the rich statistics ecosystem, with automatic-differentiation and speed.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Longer term ambitions include","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Multi-wavelength fits\nRadiative transfer embedded into the package\nSpectral and timing fits","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"SpectralFitting aims to provide highly optimised and flexible fitting algorithms, along with a library of spectral models, for use in any field of Astronomy that concerns itself with spectral data.","category":"page"},{"location":"why-and-how/#Rewriting-model-calls-during-invocation","page":"Why & How","title":"Rewriting model calls during invocation","text":"","category":"section"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"using SpectralFitting","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"SpectralFitting.jl tries to optimise model invocation through source-rewriting. For compatibility with the XSPEC model library, this is achieved through aggressive pre-allocation and shuffling of output vectors. All XSPEC models output the result of their calculation through side effects into a flux array passed as an argument, and therefore each model invocation requires its own output before addition or multiplication of fluxes may occur.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Principally, combining several models together would look like this:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"energy = collect(range(0.1, 20.0, 100))\n\nflux1 = invokemodel(energy, PowerLaw())\nflux2 = invokemodel(energy, PowerLaw(a=FitParam(3.0)))\nflux3 = invokemodel(energy, BlackBody())\nflux4 = invokemodel(energy, PhotoelectricAbsorption())\n\ntotal_flux = @. flux4 * (flux1 + flux2 + flux3)\nsum(total_flux)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"But these operations could also be performed in a different order:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"flux1 = invokemodel(energy, PowerLaw())\nflux2 = invokemodel(energy, PowerLaw(a=FitParam(3.0)))\ntotal_flux = @. flux1 + flux2\n\nflux3 = invokemodel(energy, BlackBody())\n@. total_flux = total_flux + flux3\n\nflux4 = invokemodel(energy, PhotoelectricAbsorption())\n@. total_flux = total_flux * flux4\nsum(total_flux)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Doing so would allow us to only pre-allocate 2 flux arrays, instead of 4 when using the in-place variants:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"fluxes = zeros(Float64, (length(energy) - 1, 2))\nflux1, flux2 = eachcol(fluxes)\n\ninvokemodel!(flux1, energy, PowerLaw())\ninvokemodel!(flux2, energy, PowerLaw(a=FitParam(3.0)))\n@. flux1 = flux1 + flux2\n\ninvokemodel!(flux2, energy, BlackBody())\n@. flux1 = flux1 + flux2\n\ninvokemodel!(flux2, energy, PhotoelectricAbsorption())\n@. flux1 = flux1 * flux2\nsum(flux1)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"It is precisely this re-writing that SpectralFitting performs via @generated functions. We can inspect the code used to generate the invocation body after defining a CompositeModel:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"model = PhotoelectricAbsorption() * (\n    PowerLaw() + PowerLaw(a=FitParam(3.0)) + BlackBody()\n)\n\nparams = get_value.(SpectralFitting.parameter_tuple(model))\nSpectralFitting.Reflection.assemble_composite_model_call(typeof(model), typeof(params))","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"This generated function also takes care of some other things for us, such as unpacking parameters (optionally unpacking frozen parameters separately), and ensuring any closure are passed to invokemodel if a model needs them (e.g., SurrogateSpectralModel).","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"This is achieved by moving as much information as possible about the model and its construction to its type, such that all of the invocation and parameter unpacking may be inferred at compile time.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"note: Note\nWith the addition of more pure-Julia models, non-allocating methods without aggressive pre-allocation are possible, and will be added in the future. Such methods may allow models to add or multiply in-place on the total flux array, instead of relying on later broadcasts.","category":"page"},{"location":"fitting/#Fitting-spectral-models","page":"Fitting spectral models","title":"Fitting spectral models","text":"","category":"section"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#General-reference","page":"Reference","title":"General reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SpectralFitting.Reflection]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/#SpectralFitting.Reflection._add_composite_info!-Tuple{SpectralFitting.Reflection.CompositeAggregation, Type{<:AbstractSpectralModel}, Union{Expr, Symbol}, Type}","page":"Reference","title":"SpectralFitting.Reflection._add_composite_info!","text":"Used exclusively to do recursive CompositeModel parsing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.add_objective_reduction!-Tuple{SpectralFitting.Reflection.CompositeAggregation, Symbol}","page":"Reference","title":"SpectralFitting.Reflection.add_objective_reduction!","text":"add_objective_reduction!(ra::CompositeAggregation, op::Symbol)\n\nReduces the current objective count and applies the reduction operation op to them. For example, if op is :+, and the objective count is 3, then after this function has been called the objective count will be 2 and the reduction expression\n\n@. flux2 = flux2 + flux3\n\nwill have been added to the CompositeAggregation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.assemble_composite_model_call-Tuple{Type{<:CompositeModel}, Any}","page":"Reference","title":"SpectralFitting.Reflection.assemble_composite_model_call","text":"assemble_composite_model_call(model::Type{<:CompositeModel}, parameters::Type{<:AbstractVector})\n\nAssemble the full composite model call, with objective unpacking via assemble_objective_unpack, closure and parameter assignments, model invocation, and objective reduction. Uses assemble_fast_call to put the final function body together.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.assemble_objective_unpack-Tuple{Any}","page":"Reference","title":"SpectralFitting.Reflection.assemble_objective_unpack","text":"assemble_objective_unpack(N)\n\nAssembles the statements for unpacking the objective cache into a number of views. Assembles the part of the model call that looks like:\n\nobjective1 = view(objectives, :, 1), objective2 = ...\n\nfor N objectives slices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.get_info-Tuple{Type{<:AbstractSpectralModel}, Union{Expr, Symbol}}","page":"Reference","title":"SpectralFitting.Reflection.get_info","text":"get_info(model::Type{<:AbstractSpectralModel}, lens::Lens)\n\nReturns a ModelInfo struct for a given model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.make_constructor-Tuple{Type{<:AbstractSpectralModel}, Vector, Vector, Type}","page":"Reference","title":"SpectralFitting.Reflection.make_constructor","text":"make_constructor(model::Type{<:AbstractSpectralModel}, closures::Vector, params::Vector, T::Type)\n\nCreate a constructor expression for the model.  Should return something similar to\n\n:(PowerLaw{T}(arg1, arg2, arg3)))\n\nunpacking the closures and params vectors in the appropriate places.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.parameter_lenses-Tuple{Type{<:AbstractSpectralModel}, SpectralFitting.Reflection.ModelInfo}","page":"Reference","title":"SpectralFitting.Reflection.parameter_lenses","text":"parameter_lenses(::Type{<:AbstractSpectralModel}, info::ModelInfo)\n\nReturn a vector of lenses Lens that refer to each of the models parameters. The lenses should be relative to model.lens.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.set_objective_count!-Tuple{SpectralFitting.Reflection.CompositeAggregation, Int64}","page":"Reference","title":"SpectralFitting.Reflection.set_objective_count!","text":"set_objective_count!(a::CompositeAggregation, o::Int)\n\nSet the objective count to a specific value. Will bump the maximum objective count if the new value exceeds the current maximum.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpectralFitting.Reflection.CompositeModelInfo","page":"Reference","title":"SpectralFitting.Reflection.CompositeModelInfo","text":"struct CompositeModelInfo\n    \"The parameter symbols of the model with the respective lens to the actual parameter.\"\n    parameter_symbols::Vector{Pair{Symbol,Lens}}\n    \"Each model assigned to a unique symbol.\"\n    models::Vector{Pair{Symbol,ModelInfo}}\n    \"The expression representing the folding operations of this composite model.\"\n    model_expression::Expr\n    \"Constructor and objective folding expressions, used in generating the invocation call.\"\n    expressions::Vector{Expr}\n    \"The maximum number of objective caches this model will need.\"\n    maximum_objective_cache_count::Int\n    \"How many objective caches are currently active.\"\n    objective_cache_count::Int\nend\n\nThe composite equivalent of ModelInfo, augmented to track the model symbol (a1, m3, etc.), and the model parameters (K_1, a_3, etc.)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SpectralFitting.Reflection.ModelInfo","page":"Reference","title":"SpectralFitting.Reflection.ModelInfo","text":"struct ModelInfo\n    \"All parameter symbols for the model.\"\n    symbols::Vector{Symbol}\n    \"Unique symbols generated for the parameter assignment when buildin the function call.\"\n    generated_symbols::Vector{Symbol}\n    \"Additional closure parameters that need to be handled when invoking the model.\"\n    closure_symbols::Vector{Symbol}\n    \"Unique closure generated symbols.\"\n    generated_closure_symbols::Vector{Symbol}\n    \"The lens that takes you to this model from some parent.\"\n    lens::Lens\n    \"The model type itself.\"\n    model::Type\nend\n\nAll models are parsed into a ModelInfo struct relative to their parent (in the case of composite models).\n\nThe symbols field contains all of the model parameter symbols as they are in the structure, not as they have been generated. Recall when the invocation expressions are generated, we create anonymous paramter names to avoid conflicts. These are the generated_symbols instead.\n\n\n\n\n\n","category":"type"},{"location":"walkthrough/#Walkthrough","page":"Walkthrough","title":"Walkthrough","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"warning: Warning\nThis walk through has not been fleshed out with the relevant astrophysical content yet (for example, whether a fit is good, what the different parameters mean, etc.), and so assumes some familarity with spectral fitting in general.It is also not yet complete, nor a faithful illustration of everything SpectralFitting.jl can do. It serves to illustrate similarities and differences in syntax between SpectralFitting.jl and XSPEC.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"This example walkthrough is the SpectralFitting.jl equivalent of the Walk through XSPEC from the XSPEC manual. We will use the same dataset, available for download from this link to the data files.","category":"page"},{"location":"walkthrough/#Overview","page":"Walkthrough","title":"Overview","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The first thing we want to do is load our datasets. Unlike in XSPEC, we have no requirement of being in the same directory as the data, or even that all of the response, ancillary, and spectral files be in the same place. For simplicity, we'll assume they are:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nBe sure to set DATADIR pointing to the directory where you keep the walkthrough data.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"using SpectralFitting, XSPECModels, Plots\n\nDATADIR = \"...\"\nDATADIR = length(get(ENV, \"CI\", \"\")) > 0 ? @__DIR__() * \"/../../ex-datadir\" : \"/home/lilith/Developer/jl/datasets/xspec/walkthrough\" # hide\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) ","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"This will print a little card about our data, which shows us what else SpectralFitting.jl loaded. We can see the Primary Spectrum, the Response, but that the Background and Ancillary response files are missing. That's to be expected, since we don't have those files in the dataset. ","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can check what paths it used by looking at","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"data.paths","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can load and alter any part of a dataset as we do our fitting. For example, if you have multiple different ancillary files at hand, switching them between fits is a one-liner.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"To visualize our data, we can use some of the Plots.jl recipes included in SpectralFitting.jl:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, xlims = (0.5, 70), xscale = :log10)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Note that the units are currently not divided by the energy bin widths. We can either do that manually, or use the normalize! to convert whatever units the data is currently in to the defacto standard counts s⁻¹ keV⁻¹ for fitting. Whilst we're at it, we see in the model card that there are 40 bad quality bins still present in our data. We can drop those as well, and plot the data on log-log axes:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"normalize!(data)\ndrop_bad_channels!(data)\nplot(data, ylims = (0.001, 2.0), yscale = :log10, xscale = :log10)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Note that when there are no negative axes, the scale defaults to log on the plot unless otherwise specified.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Next we want to specify a model to fit to this data. Models that are prefixed with XS_ are models that are linked from the XSPEC model library, provided via LibXSPEC_jll. For a full list of the models, see Models library.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"warning: Warning\nIt is advised to use the Julia implemented models. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see Why & how.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We will start by fitting a photoelectric absorption model that acts on a power law model:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nTo see information about a model, use the ? in the Julia REPL:julia> ?PowerLaw\nXS_PowerLaw(K, a)\n\n    •  K: Normalisation.\n\n    •  a: Photon index.\n\nExample\n≡≡≡≡≡≡≡\n...","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model = PhotoelectricAbsorption() * PowerLaw()","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"If we want to specify paramters of our model at instantiation, we can do that with","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model = PhotoelectricAbsorption() * PowerLaw(a = FitParam(3.0))","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a FittingProblem:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"prob = FittingProblem(model => data)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"SpectralFitting.jl makes a huge wealth of optimizers availble from Optimizations.jl, and others from further afield. For consistency with XSPEC, we'll use here a delayed-gratification least-squares algorithm from LsqFit.jl:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"result = fit(prob, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Here we can see the parameter vector, the estimated error on each parameter, and the measure of the fit statistic (here chi squared). We can overplot our result on our data easily:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(result)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Our model does not account for the high energy range well. We can ignore that range for now, and select everything from 0 to 15 keV and refit:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"mask_energies!(data, 0, 15)\nresult = fit(prob, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(result, label = \"PowerLaw\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The result is not yet baked into our model, and represents just the outcome of the fit. To update the parameters and errors in the model, we can use update_model!","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"update_model!(model, result)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nSince fitting and updating a model is often done in tandem, SpectralFitting.jl has both a fit and fit! method, the latter automatically updates the model parameters after fit.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"To estimate the goodness of our fit, we can mimic the goodness command from XSPEC. This will use the simulate function to simulate spectra for a dataset (here determined by the result), and fit the model to the simulated dataset. The fit statistic for each fit is then appended to an array, which we can use to plot a histogram:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"spread = goodness(result; N = 1000, seed = 42, exposure_time = data.data.spectrum.exposure_time)\nhistogram(spread, ylims = (0, 300), label = \"Simulated\")\nvline!([result.χ2], label = \"Best fit\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Note we have set the random number generator seed with seed = 42 to allow our results to be strictly reproduced.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The goodness command will log the percent of simulations with a fit statistic better than the result, but we can equivalently calculate that ourselves:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"count(<(result.χ2), spread) * 100 / length(spread)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Next we want to calculate the flux in an energy range observed by the detector. We can do this with LogFlux or XS_CalculateFlux, as they are both equivalent implementations.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can modify our model by accessing properties from the model card and writing a new expression:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"calc_flux = XS_CalculateFlux(\n    E_min = FitParam(0.2, frozen = true), \n    E_max = FitParam(2.0, frozen = true),\n    log10Flux = FitParam(-10.3, lower_limit = -100, upper_limit = 100),\n)\n\nflux_model = model.m1 * calc_flux(model.a1)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Since we used the old model to define the new one, our best fit values are automatically copied into the new model. We can now freeze the normalization, as we are using the flux integrating model to scale the powerlaw component:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"flux_model.a1.K.frozen = true\nflux_model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Looking at the data card, we see the fit domain does not include the full region that we want to integrate the flux over. We therefore need to extend the fitting domain:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"flux_problem = FittingProblem(flux_model => data)\n# TODO: domain extensions not fully implemented yet","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Now to fit we can repeat the above procedure, and even overplot the region of flux we integrated:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"flux_result = fit(flux_problem, LevenbergMarquadt())\n\nplot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(flux_result)\nvspan!([flux_model.c1.E_min.value, flux_model.c1.E_max.value], alpha = 0.5)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's try alternative models to see how they fit the data. First, an absorbed black body:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model2 = PhotoelectricAbsorption() * XS_BlackBody()","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We fit in the same way as before:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"prob2 = FittingProblem(model2 => data)\nresult2 = fit!(prob2, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's overplot this result against our power law result:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"dp = plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10,\n    legend = :bottomleft,\n)\nplot!(dp, result, label = \"PowerLaw $(round(result.χ2))\")\nplot!(dp, result2, label = \"BlackBody $(round(result2.χ2))\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Or a bremsstrahlung model:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model3 = PhotoelectricAbsorption() * XS_BremsStrahlung()\nprob3 = FittingProblem(model3 => data)\nresult3 = fit(prob3, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot!(dp, result3, label = \"Brems $(round(result3.χ2))\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's take a look at the residuals of these three models. There are utility methods for this in SpectralFitting.jl, but we can easily just interact with the result directly:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"function calc_residuals(result)\n    # select which result we want (only have one, but for generalisation to multi-model fits)\n    r = result[1] \n    y = invoke_result(r)\n    @. (r.objective - y) / sqrt(r.variance)\nend\n\ndomain = SpectralFitting.plotting_domain(data)\n\nrp = hline([0], linestyle = :dash, legend = false)\nplot!(rp,domain, calc_residuals(result), seriestype = :stepmid)\nplot!(rp, domain, calc_residuals(result2), seriestype = :stepmid)\nplot!(rp, domain, calc_residuals(result3), seriestype = :stepmid)\nrp","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can compose this figure with our previous one, and change to a linear x scale:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(dp, rp, layout = grid(2, 1, heights = [0.7, 0.3]), link = :x, xscale = :linear)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can do all that plotting work in one go with the plotresult recipe:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plotresult(\n    data,\n    [result, result2, result3],\n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10,\n    legend = :bottomleft,\n)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's modify the black body model with a continuum component","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_model = model2.m1 * (PowerLaw() + model2.a1) |> deepcopy","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nWe pipe the model to deepcopy to create a copy of all the model parameters. Not doing this means the parameters in bbpl_model will be aliased to the parameters in model2, and changing one with change the other.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We'll freeze the hydrogen column density parameter to the galactic value and refit:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_model.ηH_1.value = 4\nbbpl_model.ηH_1.frozen = true\nbbpl_model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"And fitting:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_result = fit(\n    FittingProblem(bbpl_model => data), \n    LevenbergMarquadt()\n)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's plot the result:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10,\n    legend = :bottomleft,\n)\nplot!(bbpl_result)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Update the model and fix the black body temperature to 2 keV:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"update_model!(bbpl_model, bbpl_result)\n\nbbpl_model.T_1.value = 2.0\nbbpl_model.T_1.frozen = true\nbbpl_model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Fitting:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_result2 = fit(\n    FittingProblem(bbpl_model => data), \n    LevenbergMarquadt()\n)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Overplotting this new result:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot!(bbpl_result2)","category":"page"},{"location":"walkthrough/#MCMC","page":"Walkthrough","title":"MCMC","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can use libraries like Pidgeons.jl or Turing.jl to perform Bayesian inference on our paramters. SpectralFitting.jl is designed with BYOO (Bring Your Own Optimizer) in mind, and so makes it relatively easy to get at the core fitting functions to be used with other packages.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's use Turing.jl here, which means we'll also want to use StatsPlots.jl to plot our walker chains.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"using StatsPlots\nusing Turing","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Turing.jl provides enormous control over the definition of the model, and this is not control SpectralFitting.jl wants to take away from you. Although we will provide utility scripts to do the basics, here we'll show you everything step by step to give you an overview of what you can do.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's go back to our first model:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"This gave a pretty good fit but the errors on our paramters are not well defined, being estimated only from a convariance matrix in the least-squares solver. MCMC can give us better confidence regions, and even help us uncover dependencies between paramters. Here we'll take all of our parameters and convert them into a Turing.jl model with use of their macro:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"@model function mcmc_model(domain, objective, variance, f)\n    K ~ Normal(20.0, 1.0)\n    a ~ Normal(2.2, 0.3)\n    ηH ~ truncated(Normal(0.5, 0.1); lower = 0)\n\n    pred = f(domain, [K, a, ηH])\n    return objective ~ MvNormal(pred, sqrt.(variance))\nend","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"A few things to note here: we use the Turing.jl sampling syntax ~ to say that a variable is sampled from a certain type of prior distribution. There are no fixed criteria for what a distribution can be, and we encourage you to consult the Turing.jl documentation to learn how to define your own custom probability distributions. In this case, we will use Gaussians for all our parameters, and for the means and standard deviations use the best fit and estimated errors.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"At the moment we haven't explicitly used our model, but f in this case takes the roll of invoking our model, and folding through instrument responses. We call it in much the same way as invokemodel, despite it going the extra step to fold our model. To instantiate this, we can use the SpectralFitting.jl helper functions:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"config = FittingConfig(FittingProblem(model => data))\nmm = mcmc_model(\n    make_model_domain(ContiguouslyBinned(), data),\n    make_objective(ContiguouslyBinned(), data),\n    make_objective_variance(ContiguouslyBinned(), data),\n    # _f_objective returns a function used to evaluate and fold the model through the data\n    SpectralFitting._f_objective(config),\n)\nnothing # hide","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"That's it! We're now ready to sample our model. Since all our models are implemented in Julia, we can use gradient-boosted samplers with automatic differentiation, such as NUTS. We'll walk 5000 itterations, just as a small example:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"chain = sample(mm, NUTS(), 5_000)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"In the printout we see summary statistics about or model, in this case that it has converged well (rhat close to 1 for all parameters), better estimates of the standard deviation, and various quantiles. We can plot our chains to make sure the caterpillers are healthy and fuzzy, making use of StatsPlots.jl recipes:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(chain)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Corner plots are currently broken at time of writing.","category":"page"},{"location":"models/using-models/#Using-spectral-models","page":"Using models","title":"Using spectral models","text":"","category":"section"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"using SpectralFitting\nusing Plots","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"In this page you'll find how to use the spectral model library and how to define your own models. Using the model library is as easy as invoking or composing models from the Model Index. For example:","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"model = PowerLaw()","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"In the output of the REPL we see the model name, and it's two parameters, with information about those parameters, such as the current value, the associated error (10% by defaul), the minimum and maximum values, and whether the parameter is frozen or not.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"note: Note\nSee FitParam for full details about fitable parameters.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"The parameters can be tweaked by accessing the fields","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"model.K.value = 2.0\nmodel.K.frozen = true\nmodel","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"We can invoke the model on a domain in the following way","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"domain = collect(range(0.1, 10.0, 100))\ninvokemodel(domain, model)","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"note: Note\nBy default, models are implemented to accept a single input vector with all of the low and high bin edges, and return a flux array with the flux in each energy bin. As such, it is here the case that:length(flux) == length(energy) - 1Models need not be defined as such, however. See AbstractLayout for more.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Models can be composed together following the Model algebra. That means to expressive a photoelectric absorption component acting on the power law we can write","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"model2 = PhotoelectricAbsorption() * model","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"The parameters of this CompositeModel are are copied from the expression. This means we can modify the K_1 parameter in model2 without having to worry that we are changing model.K:","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"model2.K_1.frozen = false\nmodel2","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"model","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Composite models have the same methods as single models. This means we can invoke a model in the same way","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"invokemodel(domain, model2)","category":"page"},{"location":"models/using-models/#Defining-new-models","page":"Using models","title":"Defining new models","text":"","category":"section"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"To define your own model, you need to tell the package what the model parameters are and how to invoke the model. This is all done by creating a struct which subtypes AbstractSpectralModel.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Let's create a new Additive spectral model:","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Base.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Additive}\n    K::T = FitParam(2.0)\n    p::T = FitParam(3.0)\nend\n\n# implementing a dummy add operation this function can do anything it likes, but\n# must write the output into `output` and ideally should be thread safe\nfunction SpectralFitting.invoke!(output, input, model::MyModel)\n    SpectralFitting.finite_diff_kernel!(output, input) do E\n        E + model.p\n    end\nend","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Here we used the utility method SpectralFitting.finite_diff_kernel! to ensure the additive model is appropriately scaled across the bin width.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Note that Additive models do not need to use the normalization parameter K themselves. This is because when we use invokemodel these sorts of translations are automatically applied, for compatability with external models.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Our model is now ready to use","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"model = MyModel()","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"domain = collect(range(0.1, 10.0, 100))\ninvokemodel(domain, model)","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"note: Note\nTo add new XSPEC or foreign function models, see Wrapping new XSPEC models.","category":"page"},{"location":"models/using-models/#Model-abstraction","page":"Using models","title":"Model abstraction","text":"","category":"section"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"All spectral models are a sub-type of AbstractSpectralModel.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"AbstractSpectralModel\nSpectralFitting.invoke!\nmodelkind\nnumbertype\nimplementation","category":"page"},{"location":"models/using-models/#SpectralFitting.AbstractSpectralModel","page":"Using models","title":"SpectralFitting.AbstractSpectralModel","text":"abstract type AbstractSpectralModel{T,K<:AbstractSpectralModelKind} end\n\nSupertype of all spectral models, tracking the number type T and AbstractSpectralModelKind denoted K.\n\nImplementation\n\nSub-types must implement the following interface (see the function's documentation for examples):\n\nSpectralFitting.invoke!\n\nUsage\n\nThe available API for a spectral model is detailed below:\n\ninvokemodel / invokemodel!: the primary way to invoke a model.\nallocate_model_output: allocate the output matrix for the model.\n\nThe following query functions exist:\n\nmodelkind for obtaining K\nnumbertype for obtaining T\nimplementation used to assertain whether we can do things like automatic differentation through this model.\n\nModel reflection is supported by the following functions. These are intended for internal use and are not exported.\n\nparameter_named_tuple\nparameter_tuple\nremake_model_with_parameters\ndestructure_model\n\nThe parametric type parameter T is the number type of the model and K defines the AbstractSpectralModelKind.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.invoke!","page":"Using models","title":"SpectralFitting.invoke!","text":"SpectralFitting.invoke!(output, domain, M::Type{<:AbstractSpectralModel}, params...)\n\nUsed to define the behaviour of models. Should calculate the output of the model and write in-place into output. The model parameters are passed in the model structure.\n\nwarning: Warning\nThis function should not be called directly. Use invokemodel instead. invoke! is only to define the model, not to use it. Users should always call models using invokemodel or invokemodel! to ensure normalisations and closures are accounted for.\n\nExample\n\nBase.@kwdef struct MyModel{T} <: AbstractSpectralModel{T,Multiplicative}\n    p1::T = FitParam(1.0)\n    p2::T = FitParam(2.0)\n    p3::T = FitParam(3.0)\nend\n\nwould have the arguments passed to invoke! as\n\nfunction SpectralFitting.invoke!(output, domain, model::MyModel)\n    # ...\nend\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.modelkind","page":"Using models","title":"SpectralFitting.modelkind","text":"modelkind(M::Type{<:AbstractSpectralModel})\nmodelkind(::AbstractSpectralModel)\n\nReturn the kind of model given by M: either Additive, Multiplicative, or Convolutional.\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.numbertype","page":"Using models","title":"SpectralFitting.numbertype","text":"numbertype(::AbstractSpectralModel)\n\nGet the numerical type of the model. This goes through FitParam, so that the number type returned is as close to a primative as possible.\n\nSee also paramtype.\n\nExample\n\nnumbertype(PowerLaw()) == Float64\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.implementation","page":"Using models","title":"SpectralFitting.implementation","text":"implementation(model::AbstractSpectralModel)\nimplementation(::Type{<:AbstractSpectralModel})\n\nGet the AbstractSpectralModelImplementation for a given AbstractSpectralModel or model type.\n\nThis is used primarily to learn what optimizations we can do with a model, for example propagating auto-diff gradients through a model or arbitrary precision numbers.\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#Model-methods","page":"Using models","title":"Model methods","text":"","category":"section"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"invokemodel\ninvokemodel!","category":"page"},{"location":"models/using-models/#SpectralFitting.invokemodel","page":"Using models","title":"SpectralFitting.invokemodel","text":"invokemodel(domain, model::AbstractSpectralModel)\n\nInvoke the AbstractSpectralModel given by model over the domain domain.\n\nThis function will perform any normalisation or post-processing tasks that a specific model kind may require, e.g. multiplying by a normalisation constant for Additive models.\n\nnote: Note\n\n\ninvokemodel allocates the needed output arrays based on the element type of free_params to allow automatic differentation libraries to calculate parameter gradients.\n\nIn-place non-allocating variants are the invokemodel! functions.\n\nExample\n\nmodel = PowerLaw()\ndomain = collect(range(0.1, 20.0, 100))\n\ninvokemodel(domain, model)\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.invokemodel!","page":"Using models","title":"SpectralFitting.invokemodel!","text":"invokemodel!(output, domain, model)\ninvokemodel!(output, domain, model, params::AbstractVector)\ninvokemodel!(output, domain, model, params::ParameterCache)\n\nIn-place variant of invokemodel, calculating the output of an AbstractSpectralModel given by model, optionally overriding the parameters using a ParameterCache or an AbstractVector.\n\nThe output may not necessarily be a single vector, and one should use allocate_model_output to allocate the output structure.\n\nExample\n\nmodel = PowerLaw()\ndomain = collect(range(0.1, 20.0, 100))\noutput = allocate_model_output(model, domain)\ninvokemodel!(output, domain, model)\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#Model-algebra","page":"Using models","title":"Model algebra","text":"","category":"section"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Models exist as three different kinds, defined by an AbstractSpectralModelKind trait.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"AbstractSpectralModelKind\nAdditive\nMultiplicative\nConvolutional","category":"page"},{"location":"models/using-models/#SpectralFitting.AbstractSpectralModelKind","page":"Using models","title":"SpectralFitting.AbstractSpectralModelKind","text":"abstract type AbstractSpectralModelKind\n\nAbstract type of all model kinds. The algebra of models is as follows\n\nA + A = A\nM * M = M\nM * A = A\nC(A)  = A\n\nwhere A is Additive, M is Multiplicative, and C is Convolutional. All other operations are prohibited, e.g. C(M) or M * C. To obtain M * C there must be an additive component, e.g. M * C(A).\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.Additive","page":"Using models","title":"SpectralFitting.Additive","text":"Additive <: AbstractSpectralModelKind\nAdditive()\n\nAdditive models are effectively the sources of photons, and are the principle building blocks of composite models. Every additive model has a normalisation parameter which re-scales the output by a constant factor K.\n\nnote: Note\nDefining custom additive models requires special care. See Defining new models.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.Multiplicative","page":"Using models","title":"SpectralFitting.Multiplicative","text":"Multiplicative <: AbstractSpectralModelKind\nMultiplicative()\n\nMultiplicative models act on Additive models, by element-wise multiplying the output in each domain bin of the additive model by a different factor.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#SpectralFitting.Convolutional","page":"Using models","title":"SpectralFitting.Convolutional","text":"Convolutional <: AbstractSpectralModelKind\nConvolutional()\n\nConvolutional models act on the output generated by Additive models, similar to Multiplicative models, however may convolve kernels through the output also.\n\n\n\n\n\n","category":"type"},{"location":"models/using-models/#Model-data-availability","page":"Using models","title":"Model data availability","text":"","category":"section"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Many of the XSPEC implemented models use tabular data, such as FITS, and return results interpolated from these pre-calculated tables. In some cases, these table models have data files that are multiple gigabytes in size, and would be very unwieldy to ship indiscriminantly. SpectralFitting attempts to circumnavigate this bloat by downloading the model data on an ut opus basis.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"SpectralFitting.download_model_data\nSpectralFitting.download_all_model_data","category":"page"},{"location":"models/using-models/#SpectralFitting.download_model_data","page":"Using models","title":"SpectralFitting.download_model_data","text":"SpectralFitting.download_model_data(model::AbstractSpectralModel; kwargs...)\nSpectralFitting.download_model_data(M::Type{<:AbstractSpectralModel}; kwargs...)\nSpectralFitting.download_model_data(s::Symbol; kwargs...)\n\nDownloads the model data for a model specified either by model, type M, or symbol s. Datafiles associated with a specific model may be registered using SpectralFitting.register_model_data. The download is currently unconfigurable, but permits slight control via a number of keyword arguments:\n\nprogress::Bool = true\n\nDisplay a progress bar for the download.\n\nmodel_source_url::String = \"http://www.star.bris.ac.uk/fbaker/XSPEC-model-data\"\n\nThe source URL used to download the model data.\n\nAll standard XSPEC spectral model data is currently being hosted on the University of Bristol astrophysics servers, and should be persistently available to anyone.\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/#SpectralFitting.download_all_model_data","page":"Using models","title":"SpectralFitting.download_all_model_data","text":"SpectralFitting.download_all_model_data()\n\nDownloads all model data for the models currently registered with SpectralFitting.register_model_data. Calls SpectralFitting.download_model_data to perform the download.\n\n\n\n\n\n","category":"function"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Special care must be taken if new XSPEC models are wrapped to ensure the data is available. For more on this, see Wrapping new XSPEC models.","category":"page"},{"location":"models/using-models/","page":"Using models","title":"Using models","text":"Model data may also alternatively be copied in by-hand from a HEASoft XSPEC source directory. In this case, the location to copy the data to may be determined via joinpath(SpectralFitting.LibXSPEC_jll.artifact_dir, \"spectral\", \"modelData\").","category":"page"},{"location":"#SpectralFitting.jl-Documentation","page":"Home","title":"SpectralFitting.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast and flexible spectral fitting in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting.jl is a package for defining and fitting spectral models, with a number of utilities to make model composition easy and invocation fast. SpectralFitting can be extended with LibXSPEC_jll.jl via XSPECModels.jl to expose the library of models from HEASoft XSPEC, and provides helper functions for operating with spectral data from a number of different missions. The package natively uses LsqFit.jl to fit parameters using the Levenberg-Marquardt algorithm, but makes it easy to use Optim.jl for more specialized fitting algorithms, or Turing.jl for Bayesian inference and MCMC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting is designed to be extended, such that new models are simple to create, and new dataset processing pipelines for different missions are brief to define. Where performance is key, SpectralFitting helps you define fast and AD-compatible surrogates of spectral models using Surrogates.jl, and embed them in the model composition algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, add the AstroRegistry from the University of Bristol and then install:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\npkg> registry add https://github.com/astro-group-bristol/AstroRegistry\npkg> add SpectralFitting","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpectralFitting\n# ....","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Walkthrough for an example walkthrough the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"}]
}
