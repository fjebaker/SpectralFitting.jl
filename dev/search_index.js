var documenterSearchIndex = {"docs":
[{"location":"surrogate-models/#Surrogate-models","page":"Surrogate models","title":"Surrogate models","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using SpectralFitting\nusing Plots\nENV[\"GKSwstype\"]=\"nul\"\nPlots.default(show=false)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Surrogate models allow you to create fast or memory efficient approximations of model components, or assist in optimizing some objective function directly. SpectralFitting uses the Surrogates.jl library of models, that yields pure-Julia surrogate models. Consequently, surrogate models also permit use of automatic differentiation in fitting, and are therefore powerful tools for improving fitting performance.","category":"page"},{"location":"surrogate-models/#Surrogates-overview","page":"Surrogate models","title":"Surrogates overview","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Any function may be wrapped as a surrogate model using the SurrogateSpectralModel type.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"SurrogateSpectralModel","category":"page"},{"location":"surrogate-models/#SpectralFitting.SurrogateSpectralModel","page":"Surrogate models","title":"SpectralFitting.SurrogateSpectralModel","text":"SurrogateSpectralModel <: AbstractSpectralModel\nSurrogateSpectralModel(modelkind, surrogate, params, params_symbols)\n\nUsed to wrap a surrogate function into an AbstractSpectralModel.\n\nExample\n\nCreating a surrogate function using make_surrogate_function:\n\n# build and optimize a surrogate model\nsurrogate = make_surrogate_function(model, lower_bounds, upper_bounds)\n\n# create surrogate spectral model\nsm = SurrogateSpectralModel(\n    Multiplicative(),\n    surrogate,\n    (FitParam(1.0),),\n    (:ηH,)\n)\n\nThe lower_bounds and upper_bounds must be tuples in the form (E, params...), where E denotes the bounds on the energy range to train over.\n\n\n\n\n\n","category":"type"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"To facilitate easy surrogate builds, SpectralFitting exports a number of utility functions.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"make_surrogate_function\noptimize_accuracy!","category":"page"},{"location":"surrogate-models/#SpectralFitting.make_surrogate_function","page":"Surrogate models","title":"SpectralFitting.make_surrogate_function","text":"make_surrogate_function(\n    model::M,\n    lowerbounds::T,\n    upperbounds::T;\n    optimization_samples = 200,\n    seed_samples = 50,\n    S::Type = RadialBasis,\n    sample_type = SobolSample(),\n    verbose = false,\n)\n\nCreates and optimizes a surrogate model of type S for model, using wrap_model_as_objective and  optimize_accuracy! for optimization_samples iterations. Model is initially seeded with seed_samples points prior to optimization.\n\nwarning: Warning\nAdditive models integrate energies to calculate flux, which surrogate models are currently not capable of. Results for Additive models likely to be inaccurate. This will be patched in a future version.\n\n\n\n\n\n","category":"function"},{"location":"surrogate-models/#SpectralFitting.optimize_accuracy!","page":"Surrogate models","title":"SpectralFitting.optimize_accuracy!","text":"optimize_accuracy!(\n    surr::AbstractSurrogate,\n    obj::Function,\n    lb,\n    ub;\n    sample_type::SamplingAlgorithm = SobolSample(),\n    maxiters = 200,\n    N_truth = 5000,\n    verbose = false,\n)\n\nImprove accuracy (faithfullness) of the surrogate model in recreating the objective function.\n\nSamples a new space of N_truth points between lb and ub, and calculates the objective function obj at each. Finds the point with largest MSE between surrogate and objective, and adds the point to the surrogate pool. Repeats maxiters times, adding maxiters points to surrogate model.\n\nOptionally print to stdout the MSE and iteration count with verbose = true.\n\nNote that upper- and lower-bounds should be in the form (E, params...), where E is a single energy and params are the model parameters.\n\n\n\n\n\n","category":"function"},{"location":"surrogate-models/#Creating-a-surrogate-for-XS_PhotoelectricAbsorption","page":"Surrogate models","title":"Creating a surrogate for XS_PhotoelectricAbsorption","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Before we start, let us discuss a number of benefits the use of surrogate models may bring us:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"SurrogateSpectralModel permit use of automatic differentiation.\nSurrogate models may be allocation-free depending on setup, whereas XSPEC wrappers will always have to allocate for type-conversions.\nSurrogate models may be considerably faster, especially for table models.\nSurrogate models are shareable (see Sharing surrogate models), and are tunable in size.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"XS_PhotoelectricAbsorption is an XSPEC model that is wrapped by a thin C-wrapper into Julia. The implementation of this model is a number of Fortran routines from the late 90s, including a tabulation of ~3000 lines of data that has been copied directly into the Fortran source code.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"The performance of this model represents its complexity.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"energy = collect(range(0.1, 20.0, 100))\nflux = make_flux(energy)\n\nmodel = XS_PhotoelectricAbsorption()","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Benchmarking with BenchmarkTools.jl:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using BenchmarkTools\n@btime invokemodel!($flux, $energy, $model);","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">  2.302 ms (3 allocations: 112 bytes)\n</code><button class=\"copy-button fas fa-copy\"></button></pre>","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"The surrogate we'll construct will have to be tailored a little to the data we wish to fit, as we need to specify the parameter ranges our surrogate should learn. For example, we might be interested in energies between 01 and 20 keV, with equivalent hydrogen column etaH anywhere between 10^-3 and 30. We specify these bounds using tuples","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"lower_bounds = (0.1, 1e-3)\nupper_bounds = (20.0, 30.0)\nnothing # hide","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"note: Note\nThe first index is always the energy bounds, and the subsequent indices are the parameters in the same order they are defined in the model structure.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Next, we use make_surrogate_function to build and optimize a surrogate function for our model. By default, the surrogate uses linear radial basis functions, and seeds the coefficients with a number of seed points. This function then improves the accuracy of the model using optimize_accuracy!, until a maximal number of iterations has been reached.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"For illustration purposes, we'll omit the accuracy improving step, and perform this ourselves. We can do this by setting optimization_samples = 0 in the keyword arguments:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"surrogate = make_surrogate_function(\n    model, \n    lower_bounds, \n    upper_bounds\n    ;\n    optimization_samples = 0\n)\n\n# number of points the surrogate has been trained on\nlength(surrogate.x)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can examine how well our surrogate reconstructs the model for a given test parameter:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"import Random # hide\nRandom.seed!(1) # hide\n# random test value\nηh_test = rand(1.0:30.0)\n\nf = invokemodel(energy, model, ηh_test)\n\nf̂ = map(energy[1:end-1]) do e\n    v = (e, ηh_test)\n    surrogate(v)\nend\np = plot(energy[1:end-1], f, label=\"model\", legend=:bottomright, xlabel=\"E (keV)\") # hide\nplot!(energy[1:end-1], f̂, label=\"surr\") # hide\np # hide","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now we'll use optimize_accuracy! to improve the faithfulness of our surrogate. This requires making use of wrap_model_as_objective as a little wrapper around our model:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"obj = wrap_model_as_objective(model)\n\noptimize_accuracy!(surrogate, obj, lower_bounds, upper_bounds; maxiters=250)\n\nlength(surrogate.x)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can plot the surrogate model again and see the improvement.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"new_f̂ = map(energy[2:end]) do e\n    v = (e, ηh_test)\n    surrogate(v)\nend\nplot!(energy[1:end-1], new_f̂, label=\"surr+\") # hide\np # hide","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Tight. We can also inspect the memory footprint of our model:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"# in bytes\nBase.summarysize(surrogate)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"This may be reduced by lowering maxiters in optimize_accuracy! at the cost of decreasing faithfulness. However, compare this to the Fortran tabulated source file in the XSPEC source code, which is approximately 224 Kb – about 22x larger. The surrogate models are considerably more portable at this level.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Inspecting the plot shows that there is a small domain near zero energy where the surrogate is calculating a negative value. We can either try to improve the accuracy to fix this, or specify a clamping function: for XS_PhotoelectricAbsorption, we know the multiplicative factor is constrained between 0 and 1. Therefore, we may adjust our surrogate to reflect this:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"clamped_surrogate = (v) -> clamp(surrogate(v), 0.0, 1.0)\nnothing # hide","category":"page"},{"location":"surrogate-models/#Using-a-surrogate-spectral-model","page":"Surrogate models","title":"Using a surrogate spectral model","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now that we have the surrogate model, we use SurrogateSpectralModel to wrap it into an AbstractSpectralModel. The constructor also needs to know the model kind, have a copy of the model parameters, and know which symbols to represent the parameters with.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"sm = SurrogateSpectralModel(\n    Multiplicative(),\n    clamped_surrogate,\n    (FitParam(1.0),), # must be a tuple\n    (:ηh,) # must also be a tuple\n)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can now use the familiar API and attempt to benchmark the performance:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"@btime invokemodel!($flux, $energy, $sm);","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">  50.406 μs (297 allocations: 6.19 KiB)\n</code><button class=\"copy-button fas fa-copy\"></button></pre>","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"These allocations are coming from the global closure we have in the  clamped_surrogate lambda. We can actually elide these using a proper closure:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"make_surr(surrogate) = SpectralFitting.SurrogateSpectralModel(\n    Multiplicative(),\n    (v) -> clamp(surrogate(v), 0.0, 1.0), \n    (FitParam(1.0),), \n    (:ηH,)\n)\n\nsm2 = make_surr(surrogate)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now when we benchmark","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"@btime invokemodel!($flux, $energy, $sm2);","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">  46.228 μs (0 allocations: 0 bytes)\n</code><button class=\"copy-button fas fa-copy\"></button></pre>","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Comparing this to the initial benchmark of XS_PhotoelectricAbsorption, we see about a 60x speedup, with no allocations, and this surrogate model is now automatic differentiation ready.","category":"page"},{"location":"surrogate-models/#Sharing-surrogate-models","page":"Surrogate models","title":"Sharing surrogate models","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"To export and import surrogate models, JLD2.jl is recommended.","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"transitioning-from-xspec/#Transitioning-from-XSPEC","page":"Transitioning from XSPEC","title":"Transitioning from XSPEC","text":"","category":"section"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"using-models/#Using-spectral-models","page":"Using models","title":"Using spectral models","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"using SpectralFitting\nusing Plots\nENV[\"GKSwstype\"]=\"nul\"\nPlots.default(show=false)","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Models exist as three different kinds, defined by an AbstractSpectralModelKind trait.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"AbstractSpectralModelKind\nAdditive\nMultiplicative\nConvolutional","category":"page"},{"location":"using-models/#SpectralFitting.AbstractSpectralModelKind","page":"Using models","title":"SpectralFitting.AbstractSpectralModelKind","text":"abstract type AbstractSpectralModelKind\n\nAbstract type of all model kinds. The algebra of models is as follows\n\nA + A = A\nM * M = M\nM * A = A\nC(A)  = A\n\nwhere A is Additive, M is Multiplicative, and C is Convolutional. All other operations are prohibited, e.g. C(M) or M * C. To obtain M * C there must be an additive component, e.g. M * C(A).\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.Additive","page":"Using models","title":"SpectralFitting.Additive","text":"Additive <: AbstractSpectralModelKind\nAdditive()\n\nAdditive models are effectively the sources of photons, and are the principle building blocks of composite models. Every additive model has a normalisation parameter which re-scales the flux by a constant factor K.\n\nnote: Note\nDefining custom additive models requires special care. See Defining new models.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.Multiplicative","page":"Using models","title":"SpectralFitting.Multiplicative","text":"Multiplicative <: AbstractSpectralModelKind\nMultiplicative()\n\nMultiplicative models act on Additive models, by element-wise multiplying the flux in each energy bin of the additive model by a different factor.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.Convolutional","page":"Using models","title":"SpectralFitting.Convolutional","text":"Convolutional <: AbstractSpectralModelKind\nConvolutional()\n\nConvolutional models act on the flux generated by Additive models, similar to Multiplicative models, however may convolve kernels through the flux also.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#Model-abstraction","page":"Using models","title":"Model abstraction","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"All spectral models are a sub-type of AbstractSpectralModel, including CompositeSpectralModel and SurrogateSpectralModel.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"AbstractSpectralModel\nSpectralFitting.invoke!\nmodelkind","category":"page"},{"location":"using-models/#SpectralFitting.AbstractSpectralModel","page":"Using models","title":"SpectralFitting.AbstractSpectralModel","text":"abstract type AbstractSpectralModel\n\nSupertype of all spectral models. Sub-types must implement the following interface\n\nmodelkind\nSpectralFitting.invoke!\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.invoke!","page":"Using models","title":"SpectralFitting.invoke!","text":"SpectralFitting.invoke!(flux, energy, M::Type{<:AbstractSpectralModel}, params...)\n\nUsed to define the behaviour of models. Should calculate flux of the model and write in-place into flux.\n\nwarning: Warning\nThis function should not be called directly. Use invokemodel instead.\n\nParameters are passed in in-order as defined in the model structure. For example\n\nstruct MyModel{F1,F2,F3,...} <: AbstractSpectralModel\n    p1::F1\n    p2::F2\n    p3::F3\n    # ...\nend\n\nwould have the arguments passed to invoke! as\n\nfunction SpectralFitting.invoke!(flux, energy, ::Type{<:MyModel}, p1, p2, p3, ...)\n    # ...\nend\n\nThe only exception to this are Additive models, where the normalisation parameter K is not passed to invoke!.\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.modelkind","page":"Using models","title":"SpectralFitting.modelkind","text":"modelkind(M::Type{<:AbstractSpectralModel})\n\nReturn the kind of model given by M: either Additive, Multiplicative, or Convolutional.\n\n\n\n\n\n","category":"function"},{"location":"using-models/#Instantiating-and-invoking-models","page":"Using models","title":"Instantiating and invoking models","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Models may be composed together to create more complex spectra, with the algebra defined by the AbstractSpectralModelKind. ","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"For example, a XS_PowerLaw model may multiply element-wise by a XS_PhotoelectricAbsorption model:","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"model = XS_PhotoelectricAbsorption() * XS_PowerLaw()\nmodel","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"A model may be evaluated by using invokemodel:","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, model)","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"note: Note\nXSPEC models are implemented to accept a single energy vector with all of the low and high energy bin edges, and return a flux array with the flux in each energy bin. For consistency, SpectralFitting implement models in the same way, and therefore it is always the case that:length(flux) == length(energy) - 1","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"invokemodel\ninvokemodel!","category":"page"},{"location":"using-models/#SpectralFitting.invokemodel","page":"Using models","title":"SpectralFitting.invokemodel","text":"invokemodel(energy, model)\ninvokemodel(energy, model, free_params)\n\nInvoke the AbstractSpectralModel given by model, optionally overriding the free parameters with values given in free_params. free_params may be a vector or tuple with element type AbstractFitParameter or Number.\n\nThis function, unlike SpectralFitting.invoke! used to define models, is sensitive to performing any normalisation or post-processing tasks that a specific model kind may require.\n\nnote: Note\nUsers should always call models using invokemodel or invokemodel! to ensure normalisations and closures are accounted for.\n\ninvokemodel allocates the needed flux arrays based on the element type of free_params to allow automatic differentation libraries to calculate parameter gradients.\n\nIn-place non-allocating variants are the invokemodel! functions.\n\nExample\n\nmodel = XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, model)\n\np0 = [0.1, 2.0] # change K and a\ninvokemodel(energy, model, p0)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.invokemodel!","page":"Using models","title":"SpectralFitting.invokemodel!","text":"invokemodel!(flux, energy, model)\ninvokemodel!(flux, energy, model, free_params)\ninvokemodel!(flux, energy, model, free_params, frozen_params)\n\nIn-place variant of invokemodel, calculating the flux of an AbstractSpectralModel given by model, optionally overriding the free and/or frozen parameter values. These arguments may be a vector or tuple with element type AbstractFitParameter or Number.\n\nThe number of fluxes to allocate for a model may change if using any CompositeSpectralModel as the model. It is generally recommended to use flux_count to ensure the correct number of flux arrays are allocated with make_fluxes when using composite models.\n\nSingle spectral model components should use make_flux instead.\n\nExample\n\nmodel = XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\nflux = make_flux(energy)\ninvokemodel!(flux, energy, model)\n\np0 = [0.1, 2.0] # change K and a\ninvokemodel!(flux, energy, model, p0)\n\n\n\n\n\ninvokemodel!(flux, energy, ::Type{<:AbstractSpectralModel}, params...)\n\nSpecialisation of invokemodel! which dispatches on types. This is primarily used in the generated functions, to assemble efficient model calls at compile time. In general, users should prefer one of the other dispatches.\n\n\n\n\n\n","category":"function"},{"location":"using-models/#Utilities","page":"Using models","title":"Utilities","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"SpectralFitting defines a number of utility functions for model introspection and manipulation.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"flux_count\nget_param\nget_param_count\nget_param_types\nget_param_symbols\nget_param_symbol_pairs\nget_all_model_params\nget_all_model_params_by_value","category":"page"},{"location":"using-models/#SpectralFitting.flux_count","page":"Using models","title":"SpectralFitting.flux_count","text":"flux_count(model::AbstractSpectralModel)\n\nReturns the number of flux arrays the model needs when using invokemodel!.\n\nExample\n\nmodel = XS_PhotoelectricAbsorption() * XS_PowerLaw()\nflux_count(model)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_param","page":"Using models","title":"SpectralFitting.get_param","text":"get_param(model::AbstractSpectralModel, s::Symbol)\n\nGet a parameter from an AbstractSpectralModel by symbol.\n\nExample\n\nmodel = XS_BlackBody()\nget_param(model, :K)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_param_count","page":"Using models","title":"SpectralFitting.get_param_count","text":"get_param_count(model::AbstractSpectralModel)\nget_param_count(M::Type{<:AbstractSpectralModel})\n\nGet the number of parameters a given AbstractSpectralModel has.\n\nExample\n\nmodel = XS_BlackBody() + XS_PowerLaw()\nget_param_count(model)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_param_types","page":"Using models","title":"SpectralFitting.get_param_types","text":"get_param_types(model::AbstractSpectralModel)\nget_param_types(M::Type{<:AbstractSpectralModel})\n\nGet a Vector{Type} with the type of each parameters in a given AbstractSpectralModel.\n\nExample\n\nmodel = XS_BlackBody() + XS_PhotoelectricAbsorption() * XS_PowerLaw()\nget_param_types(model)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_param_symbols","page":"Using models","title":"SpectralFitting.get_param_symbols","text":"get_param_symbols(model::AbstractSpectralModel)\nget_param_symbols(M::Type{<:AbstractSpectralModel})\n\nGet a Vector{Symbol} with the symbol of each parameters in a given AbstractSpectralModel.\n\nExample\n\nmodel = XS_PhotoelectricAbsorption() * XS_Laor()\nget_param_symbols(model)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_param_symbol_pairs","page":"Using models","title":"SpectralFitting.get_param_symbol_pairs","text":"get_param_symbol_pairs(m::AbstractSpectralModel)\n\nGet a generator yielding ::Pair{Symbol,T} of all model parameter values and their symbols, for an AbstractSpectralModel.\n\nExample\n\nmodel = XS_BlackBody() + XS_PowerLaw()\nget_param_symbol_pairs(model)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_all_model_params","page":"Using models","title":"SpectralFitting.get_all_model_params","text":"get_all_model_params(m::AbstractSpectralModel)\n\nGet a generator of all model parameters of an AbstractSpectralModel.\n\nExample\n\nmodel = XS_BlackBody() + XS_PowerLaw()\nget_all_model_params(model)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.get_all_model_params_by_value","page":"Using models","title":"SpectralFitting.get_all_model_params_by_value","text":"get_all_model_params_by_value(m::AbstractSpectralModel)\n\nGet a generator of all model parameter values of an AbstractSpectralModel. See get_value.\n\nExample\n\nmodel = XS_BlackBody() + XS_PowerLaw()\nget_all_model_params_by_value(model)\n\n\n\n\n\n","category":"function"},{"location":"composite-models/#Composite-models","page":"Composite models","title":"Composite models","text":"","category":"section"},{"location":"composite-models/","page":"Composite models","title":"Composite models","text":"The model algebra defined by the AbstractSpectralModelKind yields instances of CompositeSpectralModel, nested to various degrees. These composite models are designed to make as much information about the spectral model available at compile-time, such that rich and optimized generated functions may be assembled purely from the Julia types (see Why & how).","category":"page"},{"location":"composite-models/","page":"Composite models","title":"Composite models","text":"CompositeSpectralModel\nAbstractCompositeOperator\nAdditionOperator\nMultiplicationOperator\nConvolutionOperator\noperation_symbol","category":"page"},{"location":"composite-models/#SpectralFitting.CompositeSpectralModel","page":"Composite models","title":"SpectralFitting.CompositeSpectralModel","text":"CompositeSpectralModel{M1,M2,O} <: AbstractSpectralModel\nCompositeSpectralModel(left_model, right_model, op::AbstractCompositeOperator)\n\nType resulting from operations combining any number of AbstractSpectralModel via the model algebra defined from AbstractSpectralModelKind.\n\nEach operation binary operation in the model algebra is encoded in the parametric types of the CompositeSpectralModel, where the operation is given by an AbstractCompositeOperator. Composite models adopt the model kind of the right model, i.e. M2, and obey the model algebra accordingly.\n\nComposite models very rarely need to be constructed directly, and are instead obtained by regular model operations.\n\nExample\n\nmodel = XS_PhotoelectricAbsorption() * (XS_PowerLaw() + XS_BlackBody())\ntypeof(model) <: CompositeSpectralModel # true\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.AbstractCompositeOperator","page":"Composite models","title":"SpectralFitting.AbstractCompositeOperator","text":"abstract type AbstractCompositeOperator\n\nSuperype of all composition operators. Used to implement the model algebra of AbstractSpectralModelKind through a trait system.\n\nThe Julia symbol corresponding to a given AbstractCompositeOperator may be obtained through operation_symbol.\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.AdditionOperator","page":"Composite models","title":"SpectralFitting.AdditionOperator","text":"AdditionOperator <: AbstractCompositeOperator\nAdditionOperator()\n\nCorresponds to the :(+) symbol.\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.MultiplicationOperator","page":"Composite models","title":"SpectralFitting.MultiplicationOperator","text":"MultiplicationOperator <: AbstractCompositeOperator\nMultiplicationOperator()\n\nCorresponds to the :(*) symbol.\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.ConvolutionOperator","page":"Composite models","title":"SpectralFitting.ConvolutionOperator","text":"ConvolutionOperator <: AbstractCompositeOperator\nConvolutionOperator()\n\nHas no corresponding symbol, since it invokes a function call C(A).\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.operation_symbol","page":"Composite models","title":"SpectralFitting.operation_symbol","text":"operation_symbol(::AbstractCompositeOperator)\noperation_symbol(::Type{<:AbstractCompositeOperator})\n\nObtain the model symbol from a given AbstractCompositeOperator.\n\n\n\n\n\n","category":"function"},{"location":"models/#Models-index","page":"Model index","title":"Models index","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"using SpectralFitting","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"Models wrapped from XSPEC implementations are prefixed with XS_*, whereas pure-Julia models are simply named, e.g. XS_PowerLaw in XSPEC vs PowerLaw in Julia.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"The available models are","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"Pages = [\"models.md\"]\nOrder = [:type]","category":"page"},{"location":"models/#Julia-models","page":"Model index","title":"Julia models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"PowerLaw\nBlackBody","category":"page"},{"location":"models/#SpectralFitting.PowerLaw","page":"Model index","title":"SpectralFitting.PowerLaw","text":"XS_PowerLaw(K, a)\n\nK\nNormalisation. Default: FitParam(1.0)\na\nPhoton index. Default: FitParam(0.5)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, PowerLaw())\n\n                        PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.BlackBody","page":"Model index","title":"SpectralFitting.BlackBody","text":"XS_BlackBody(K, T)\n\nK\nNormalisation. Default: FitParam(1.0)\nkT\nTemperature (keV). Default: FitParam(3.0)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BlackBody())\n\n                        BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │     :'      '':.                       │\n       │   .'           ':.                     │\n       │  .:               '..                  │\n       │  :                  ':.                │\n       │ .'                     ':..            │\n       │ :                         ''...        │\n       │:                              '''....  │\n     0 │:                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#Defining-new-models","page":"Model index","title":"Defining new models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"To define a new Julia model, we need only implement the AbstractSpectralModel interface. As a pedagogical example, consider an implementation of PowerLaw:","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"# define the model and parameters\n@with_kw struct PowerLaw{F1,F2} <: AbstractSpectralModel\n    \"Normalisation.\"\n    K::F1 = FitParam(1.0)\n    \"Photon index.\"\n    a::F2 = FitParam(0.5)\nend\n\n# tell the package what kind of model this is\nmodelkind(::Type{<:PowerLaw}) = Additive()\n\n# define how the model acts: \n# all of the parameters are passed, in order, as arguments\nfunction SpectralFitting.invoke!(flux, energy, ::Type{<:PowerLaw}, a)\n    α = 1 - a\n    α⁻¹ = inv(α)\n    SpectralFitting.finite_diff_kernel!(flux, energy) do E\n        α⁻¹ * E^α\n    end\nend","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"Note that each parameter has its own parametric type, here ::F1 and ::F2. This is so that the type of fit parameters can be changed, or alternative number types inserted (see Why & how). The standard parameter type is FitParam, which is what we have used here.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"The model is defined to be additive by overloading modelkind.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"danger: Danger\nAdditive models must have a normalisation parameter with the symbol K, which is, however, not passed to SpectralFitting.invoke!. Multiplicative and convolutional models have no such requirements.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"We have also used the SpectralFitting.finite_diff_kernel! utility function, which is designed to help us efficiently compute finite-difference integrations of flux, just as XSPEC does.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"note: Note\nTo add additional XSPEC models, see Wrapping new XSPEC models.","category":"page"},{"location":"models/#XSPEC-models","page":"Model index","title":"XSPEC models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"XS_PowerLaw\nXS_BlackBody\nXS_BremsStrahlung\nXS_Laor\nXS_DiskLine\nXS_PhotoelectricAbsorption\nXS_WarmAbsorption\nXS_CalculateFlux\nXS_KerrDisk\nXS_KyrLine","category":"page"},{"location":"models/#SpectralFitting.XS_PowerLaw","page":"Model index","title":"SpectralFitting.XS_PowerLaw","text":"XS_PowerLaw(K, a)\n\nK\nNormalisation. Default: FitParam(1.0)\na\nPhoton index. Default: FitParam(0.5)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PowerLaw())\n\n                      XS_PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_BlackBody","page":"Model index","title":"SpectralFitting.XS_BlackBody","text":"XS_BlackBody(K, T)\n\nK\nNormalisation. Default: FitParam(1.0)\nT\nTemperature (keV). Default: FitParam(3.0)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BlackBody())\n\n                      XS_BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │    .:       ''.                        │\n       │   .'           ':.                     │\n       │   :              ''..                  │\n       │  :                  ':.                │\n       │ :                     '':.             │\n       │.:                         ''..         │\n       │:                              '':....  │\n     0 │'                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_BremsStrahlung","page":"Model index","title":"SpectralFitting.XS_BremsStrahlung","text":"XS_BremsStrahlung(K, T)\n\nK\nNormalisation. Default: FitParam(1.0)\nT\nPlasma temperature (keV). Default: FitParam(7.0)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BremsStrahlung())\n\n                  XS_BremsStrahlung\n     ┌────────────────────────────────────────┐\n   2 │                                        │\n     │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │'.                                      │\n     │ :                                      │\n   0 │  ':....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_Laor","page":"Model index","title":"SpectralFitting.XS_Laor","text":"XS_Laor(K, lineE, a, inner_r, outer_r, incl)\n\nK\nNormalisation. Default: FitParam(1.0)\nlineE\nRest frame line energy (keV). Default: FitParam(6.4)\na\nPower law dependence of emissitivy. Scales R⁻ᵅ. Default: FrozenFitParam(3.0)\ninner_r\nInner radius of the accretion disk (GM/c). Default: FrozenFitParam(1.235)\nouter_r\nOuter radius of the accretion disk (GM/c). Default: FrozenFitParam(400.0)\nincl\nDisk inclination angle to line of sight (degrees, 0 is pole on). Default: FitParam(30.0)\n\nExample\n\nenergy = collect(range(0.1, 10.0, 100))\ninvokemodel(energy, XS_Laor())\n\n                          XS_Laor\n        ┌────────────────────────────────────────┐\n   0.06 │                                        │\n        │                                        │\n        │                         ::             │\n        │                         ::             │\n        │                        : :             │\n        │                       :  :             │\n        │                      :   :             │\n        │                     :'   :             │\n        │                   .:     :             │\n        │                  :'      :             │\n        │                .'        :             │\n        │              .:'         :             │\n        │            ..'           :             │\n        │          .:'              :            │\n      0 │.......:''                 :............│\n        └────────────────────────────────────────┘\n         0                                     10\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_DiskLine","page":"Model index","title":"SpectralFitting.XS_DiskLine","text":"XS_DiskLine(K, lineE, β, inner_r, outer_r, incl)\n\nK\nNormalisation. Default: FitParam(1.0)\nlineE\nRest frame line energy (keV). Default: FitParam(6.7)\nβ\nPower law dependence of emissitivy. If < 10, scales Rᵅ. Default: FrozenFitParam(-2.0)\ninner_r\nInner radius of the accretion disk (GM/c). Default: FrozenFitParam(10.0)\nouter_r\nOuter radius of the accretion disk (GM/c). Default: FrozenFitParam(1000.0)\nincl\nDisk inclination angle to line of sight (degrees, 0 is pole on). Default: FitParam(30.0)\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_DiskLine())\n\n                        XS_DiskLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │                           .            │\n        │                           :            │\n        │                           ::           │\n        │                         . ::           │\n        │                         : ::           │\n        │                         :'':           │\n        │                        .'  :           │\n        │                        :    :          │\n        │                        :    :          │\n        │                       .'    :          │\n        │                       :     :          │\n        │                     .:      '.         │\n        │                   .:'        :         │\n      0 │...............:'''           :.........│\n        └────────────────────────────────────────┘\n         4                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_PhotoelectricAbsorption","page":"Model index","title":"SpectralFitting.XS_PhotoelectricAbsorption","text":"XS_PhotoelectricAbsorption(ηH)\n\nηH\nEquivalent hydrogen column (units of 10²² atoms per cm⁻²). Default: FitParam(1.0)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PhotoelectricAbsorption())\n\n             XS_PhotoelectricAbsorption\n     ┌────────────────────────────────────────┐\n   1 │       ...''''''''''''''''''''''''''''''│\n     │      .'                                │\n     │     :                                  │\n     │    :'                                  │\n     │    :                                   │\n     │   :                                    │\n     │   :                                    │\n     │   :                                    │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │ :                                      │\n   0 │.:                                      │\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_WarmAbsorption","page":"Model index","title":"SpectralFitting.XS_WarmAbsorption","text":"XS_WarmAbsorption(ηH, Ew)\n\nηH\nEquivalent hydrogen column (units of 10²² atoms per cm⁻²). Default: FitParam(1.0)\nEw\nWindow energy (keV). Default: FitParam(1.0)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_WarmAbsorption())\n\n                    XS_WarmAbsorption\n       ┌────────────────────────────────────────┐\n     1 │':      ...''':'''''''''''''''''''''''''│\n       │ :    .:'                               │\n       │ :   .'                                 │\n       │ :  .:                                  │\n       │ :  :                                   │\n       │ :  :                                   │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ ::                                     │\n       │ ::                                     │\n       │  :                                     │\n       │  :                                     │\n   0.2 │  :                                     │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_CalculateFlux","page":"Model index","title":"SpectralFitting.XS_CalculateFlux","text":"XS_CalculateFlux(E_min, E_max, lg10Flux)\n\nE_min\nMinimum energy. Default: FrozenFitParam(0.2)\nE_max\nMaximum energy. Default: FrozenFitParam(2.0)\nlg10Flux\nlog (base 10) flux in erg / cm^2 / s Default: FitParam(-10.0, lowerlimit = -Inf, upperlimit = 0.0)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_KerrDisk","page":"Model index","title":"SpectralFitting.XS_KerrDisk","text":"XS_KerrDisk(K, lineE, index1, index2, break_r, a, incl, inner_r, outer_r)\n\nK\nNormalisation. Default: FitParam(1.0)\nlineE\nRest frame line energy (keV). Default: FrozenFitParam(6.4)\nindex1\nEmissivity index for inner disk. Default: FrozenFitParam(3.0)\nindex2\nEmissivity index for outer disk. Default: FrozenFitParam(3.0)\nbreak_r\nBreak radius seperating inner and outer disk (gᵣ). Default: FrozenFitParam(6.0)\na\nDimensionless black hole spin. Default: FitParam(0.998)\nincl\nDisk inclination angle to line of sight (degrees). Default: FrozenFitParam(30.0)\ninner_r\nInner radius of the disk in units of rₘₛ. Default: FrozenFitParam(1.0)\nouter_r\nOuter radius of the disk in units of rₘₛ. Default: FrozenFitParam(400.0)\nz\nRedshift. Default: FrozenFitParam(0.0)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KerrDisk())\n\n                       XS_KerrDisk\n       ┌────────────────────────────────────────┐\n   0.1 │            :                           │\n       │            :                           │\n       │           ::                           │\n       │           : :                          │\n       │           : :                          │\n       │          :  :                          │\n       │          :  :                          │\n       │         :   :                          │\n       │         :   :                          │\n       │        :    :                          │\n       │       .'    :                          │\n       │       :     :                          │\n       │    ..'      :                          │\n       │    :'       :                          │\n     0 │...:'        :..........................│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_KyrLine","page":"Model index","title":"SpectralFitting.XS_KyrLine","text":"XS_KyrLine(K, a, θ_obs, inner_r, ms_flag, outer_r, lineE, α, β, break_r, z, limb)\n\nK\nNormalisation. Default: FitParam(1.0)\na\nDimensionless black hole spin. Default: FitParam(0.998)\nθ_obs\nObserver inclination (0 is on pole, degrees). Default: FitParam(30.0)\ninner_r\nInner radius of the disk in units of GM/c² Default: FrozenFitParam(1.0)\nms_flag\n0: integrate from rᵢₙ. 1: integrate from rₘₛ. Default: FrozenFitParam(1)\nouter_r\nOuter radius of the disk in units of GM/c² Default: FrozenFitParam(400.0)\nlineE\nRest frame line energy (keV). Default: FrozenFitParam(6.4)\nα\nDefault: FrozenFitParam(3.0)\nβ\nDefault: FrozenFitParam(3.0)\nbreak_r\nBreak radius seperating inner and outer disk (GM/c²). Default: FrozenFitParam(400.0)\nz\nOverall Doppler shift. Default: FrozenFitParam(0.0)\nlimb\n0: isotropic emission, 1: Laor's limb darkening, 2: Haard's limb brightening. Default: FrozenFitParam(1)\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KyrLine())\n\n                       XS_KyrLine\n       ┌────────────────────────────────────────┐\n   0.1 │                                        │\n       │            ::                          │\n       │           .':                          │\n       │           : :                          │\n       │           : :                          │\n       │          :  :                          │\n       │          :  :                          │\n       │         :   :                          │\n       │        .:   :                          │\n       │        :    :                          │\n       │       .'    :                          │\n       │       :     :                          │\n       │     .:      :                          │\n       │    .:       :                          │\n     0 │...:'        :..........................│\n       └────────────────────────────────────────┘\n        0                                     20\n\n\n\n\n\n","category":"type"},{"location":"models/#Wrapping-new-XSPEC-models","page":"Model index","title":"Wrapping new XSPEC models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"SpectralFitting exports a helpful macro to facilitate wrapping additional XSPEC models.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"@xspecmodel","category":"page"},{"location":"models/#SpectralFitting.@xspecmodel","page":"Model index","title":"SpectralFitting.@xspecmodel","text":"@xspecmodel model_kind func_name model\n\nUsed to wrap additional XSPEC models, generating the needed AbstractSpectralModel implementation.\n\nExamples\n\n@xspecmodel Additive :C_powerlaw struct XS_PowerLaw{F1,F2}\n    \"Normalisation.\"\n    K::F1 = FitParam(1.0)\n    \"Photon index.\"\n    a::F2 = FitParam(0.5)\nend\n\nWe define a new structure XS_PowerLaw with two parameters, but since the model is Additive, only a single parameter (a) is passed to the XSPEC function. The function we bind to this model is :C_powerlaw from the XSPEC C wrappers.\n\nThe macro will then generate the following functions\n\nmodelkind(::Type{<:XS_PowerLaw})\nimplementation(::Type{<:XS_PowerLaw})\ninvoke!(::Type{<:XS_PowerLaw})\n\n\n\n\n\n","category":"macro"},{"location":"models/#Generating-model-fingerprints","page":"Model index","title":"Generating model fingerprints","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"To generate the unicode plot to add as a fingerprint, we use a simple function:","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"using UnicodePlots\n\nfunction plotmodel(energy, model)\n    flux = invokemodel(energy, model)\n    lineplot(\n        energy[1:end-1], \n        flux, \n        title=String(SpectralFitting.model_base_name(typeof(model))), \n        xlabel=\"E (keV)\", \n        canvas=DotCanvas\n    )\nend\n\n# e.g. for XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\nplotmodel(energy, XS_PowerLaw())","category":"page"},{"location":"why-and-how/#Why-and-how","page":"Why & How","title":"Why & how","text":"","category":"section"},{"location":"fitting/#Fitting-spectral-models","page":"Fitting spectral models","title":"Fitting spectral models","text":"","category":"section"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Energy-and-flux-utility-functions","page":"Reference","title":"Energy and flux utility functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"make_flux\nmake_fluxes","category":"page"},{"location":"reference/#Utility-functions-for-defining-new-models","page":"Reference","title":"Utility functions for defining new models","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"SpectralFitting.finite_diff_kernel!\nwrap_model_as_objective","category":"page"},{"location":"reference/#SpectralFitting.finite_diff_kernel!","page":"Reference","title":"SpectralFitting.finite_diff_kernel!","text":"finite_diff_kernel!(f::Function, flux, energy)\n\nCalculates the finite difference of the function f over the energy bin between the high and low bin edges, via\n\nc_i = f(E_itexthigh) - f(E_itextlow)\n\nsimilar to evaluating the limits of the integral between E_itexthigh and E_itextlow.\n\nThis utility function is primarily used for Additive models to ensure the flux per bin is normalised for the energy over the bin.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SpectralFitting.wrap_model_as_objective","page":"Reference","title":"SpectralFitting.wrap_model_as_objective","text":"wrap_model_as_objective(model::AbstractSpectralModel; ΔE = 1e-1)\nwrap_model_as_objective(M::Type{<:AbstractSpectralModel}; ΔE = 1e-1)\n\nWrap a spectral model into an objective function for building/optimizing a surrogate model. Returns an anonymous function taking the tuple (E, params...) as the argument, and returning a single flux value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Introspection","page":"Reference","title":"Introspection","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"has_closure_params\nget_closure_param_fields\nmodel_base_name","category":"page"},{"location":"#SpectralFitting.jl-Documentation","page":"Home","title":"SpectralFitting.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast and flexible spectral fitting in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting.jl is a package for defining and using spectral models, with a number of utilities to make model composition easy and invocation fast. SpectralFitting wraps LibXSPEC_jll.jl to expose the library of models from HEASoft XSPEC, and provides helper functions for operating with spectral data from a number of different missions. The package natively uses LsqFit.jl to fit parameters using the Levenberg-Marquardt algorithm, but makes it easy to use Optim.jl for more specialized fitting algorithms, or Turing.jl for Bayesian inference and MCMC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting is designed to be extended, such that new models are simple to create, and new dataset processing pipelines for different missions are brief to define. Where performance is key, SpectralFitting helps you define fast and AD-compatible surrogates of spectral models using Surrogates.jl, and embed them in the model composition algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, install LibXSPEC_jll and SpectralFitting:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/astro-group-bristol/LibXSPEC_jll.jl\")\nPkg.add(url = \"https://github.com/fjebaker/SpectralFitting.jl\")\n\nusing SpectralFitting\n# ....","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"}]
}
