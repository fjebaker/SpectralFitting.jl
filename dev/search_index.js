var documenterSearchIndex = {"docs":
[{"location":"surrogate-models/#Surrogate-models","page":"Surrogate models","title":"Surrogate models","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using SpectralFitting\nusing Plots\nENV[\"GKSwstype\"]=\"nul\"\nPlots.default(show=false)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Surrogate models allow you to create fast or memory efficient approximations of model components, or assist in optimizing some objective function directly. SpectralFitting uses the Surrogates.jl library of models, that yields pure-Julia surrogate models. Consequently, surrogate models also permit use of automatic differentiation in fitting, and are therefore powerful tools for improving fitting performance.","category":"page"},{"location":"surrogate-models/#Surrogates-overview","page":"Surrogate models","title":"Surrogates overview","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Any function may be wrapped as a surrogate model using the SurrogateSpectralModel type.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"SurrogateSpectralModel","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"To facilitate easy surrogate builds, SpectralFitting exports a number of utility functions.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"make_surrogate_function\noptimize_accuracy!","category":"page"},{"location":"surrogate-models/#Creating-a-surrogate-for-XS_PhotoelectricAbsorption","page":"Surrogate models","title":"Creating a surrogate for XS_PhotoelectricAbsorption","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Before we start, let us discuss a number of benefits the use of surrogate models may bring us:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"SurrogateSpectralModel permit use of automatic differentiation.\nSurrogate models may be allocation-free depending on setup, whereas XSPEC wrappers will always have to allocate for type-conversions.\nSurrogate models may be considerably faster, especially for table models.\nSurrogate models are shareable (see Sharing surrogate models), and are tunable in size.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"XS_PhotoelectricAbsorption is an XSPEC model that is wrapped by a thin C-wrapper into Julia. The implementation of this model is a number of Fortran routines from the late 90s, including a tabulation of ~3000 lines of data that has been copied directly into the Fortran source code.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"The performance of this model represents its complexity.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"energy = collect(range(0.1, 20.0, 100))\nmodel = XS_PhotoelectricAbsorption()\n\nflux = make_flux(model, energy)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Benchmarking with BenchmarkTools.jl:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"using BenchmarkTools\n@btime invokemodel!($flux, $energy, $model);","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">  2.302 ms (3 allocations: 112 bytes)\n</code><button class=\"copy-button fas fa-copy\"></button></pre>","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"The surrogate we'll construct will have to be tailored a little to the data we wish to fit, as we need to specify the parameter ranges our surrogate should learn. For example, we might be interested in energies between 01 and 20 keV, with equivalent hydrogen column etaH anywhere between 10^-3 and 30. We specify these bounds using tuples","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"lower_bounds = (0.1, 1e-3)\nupper_bounds = (20.0, 30.0)\nnothing # hide","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"note: Note\nThe first index is always the energy bounds, and the subsequent indices are the parameters in the same order they are defined in the model structure.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Next, we use make_surrogate_function to build and optimize a surrogate function for our model. By default, the surrogate uses linear radial basis functions, and seeds the coefficients with a number of seed points. This function then improves the accuracy of the model using optimize_accuracy!, until a maximal number of iterations has been reached.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"For illustration purposes, we'll omit the accuracy improving step, and perform this ourselves. We can do this by setting optimization_samples = 0 in the keyword arguments:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"surrogate = make_surrogate_function(\n    model, \n    lower_bounds, \n    upper_bounds\n    ;\n    optimization_samples = 0\n)\n\n# number of points the surrogate has been trained on\nlength(surrogate.x)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can examine how well our surrogate reconstructs the model for a given test parameter:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"import Random # hide\nRandom.seed!(1) # hide\n# random test value\nηh_test = rand(1.0:30.0)\n\nf = invokemodel(energy, model, ηh_test)\n\nf̂ = map(energy[1:end-1]) do e\n    v = (e, ηh_test)\n    surrogate(v)\nend\np = plot(energy[1:end-1], f, label=\"model\", legend=:bottomright, xlabel=\"E (keV)\") # hide\nplot!(energy[1:end-1], f̂, label=\"surr\") # hide\np # hide","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now we'll use optimize_accuracy! to improve the faithfulness of our surrogate. This requires making use of wrap_model_as_objective as a little wrapper around our model:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"obj = wrap_model_as_objective(model)\n\noptimize_accuracy!(surrogate, obj, lower_bounds, upper_bounds; maxiters=250)\n\nlength(surrogate.x)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can plot the surrogate model again and see the improvement.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"new_f̂ = map(energy[2:end]) do e\n    v = (e, ηh_test)\n    surrogate(v)\nend\nplot!(energy[1:end-1], new_f̂, label=\"surr+\") # hide\np # hide","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Tight. We can also inspect the memory footprint of our model:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"# in bytes\nBase.summarysize(surrogate)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"This may be reduced by lowering maxiters in optimize_accuracy! at the cost of decreasing faithfulness. However, compare this to the Fortran tabulated source file in the XSPEC source code, which is approximately 224 Kb – about 22x larger. The surrogate models are considerably more portable at this level.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Inspecting the plot shows that there is a small domain near zero energy where the surrogate is calculating a negative value. We can either try to improve the accuracy to fix this, or specify a clamping function: for XS_PhotoelectricAbsorption, we know the multiplicative factor is constrained between 0 and 1. Therefore, we may adjust our surrogate to reflect this:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"clamped_surrogate = (v) -> clamp(surrogate(v), 0.0, 1.0)\nnothing # hide","category":"page"},{"location":"surrogate-models/#Using-a-surrogate-spectral-model","page":"Surrogate models","title":"Using a surrogate spectral model","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now that we have the surrogate model, we use SurrogateSpectralModel to wrap it into an AbstractSpectralModel. The constructor also needs to know the model kind, have a copy of the model parameters, and know which symbols to represent the parameters with.","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"sm = SurrogateSpectralModel(\n    Multiplicative(),\n    clamped_surrogate,\n    (FitParam(1.0),), # must be a tuple\n    (:ηh,) # must also be a tuple\n)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"We can now use the familiar API and attempt to benchmark the performance:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"@btime invokemodel!($flux, $energy, $sm);","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">  50.406 μs (297 allocations: 6.19 KiB)\n</code><button class=\"copy-button fas fa-copy\"></button></pre>","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"These allocations are coming from the global closure we have in the  clamped_surrogate lambda. We can actually elide these using a proper closure:","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"make_surr(surrogate) = SpectralFitting.SurrogateSpectralModel(\n    Multiplicative(),\n    (v) -> clamp(surrogate(v), 0.0, 1.0), \n    (FitParam(1.0),), \n    (:ηH,)\n)\n\nsm2 = make_surr(surrogate)","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Now when we benchmark","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"@btime invokemodel!($flux, $energy, $sm2);","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"<pre class=\"documenter-example-output\"><code class=\"nohighlight hljs ansi\">  46.228 μs (0 allocations: 0 bytes)\n</code><button class=\"copy-button fas fa-copy\"></button></pre>","category":"page"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"Comparing this to the initial benchmark of XS_PhotoelectricAbsorption, we see about a 60x speedup, with no allocations, and this surrogate model is now automatic differentiation ready.","category":"page"},{"location":"surrogate-models/#Sharing-surrogate-models","page":"Surrogate models","title":"Sharing surrogate models","text":"","category":"section"},{"location":"surrogate-models/","page":"Surrogate models","title":"Surrogate models","text":"To export and import surrogate models, JLD2.jl is recommended.","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"transitioning-from-xspec/#Transitioning-from-XSPEC","page":"Transitioning from XSPEC","title":"Transitioning from XSPEC","text":"","category":"section"},{"location":"datasets/#Datasets","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"using-models/#Using-spectral-models","page":"Using models","title":"Using spectral models","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"using SpectralFitting\nusing Plots\nENV[\"GKSwstype\"]=\"nul\"\nPlots.default(show=false)","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Models exist as three different kinds, defined by an AbstractSpectralModelKind trait.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"AbstractSpectralModelKind\nAdditive\nMultiplicative\nConvolutional","category":"page"},{"location":"using-models/#SpectralFitting.AbstractSpectralModelKind","page":"Using models","title":"SpectralFitting.AbstractSpectralModelKind","text":"abstract type AbstractSpectralModelKind\n\nAbstract type of all model kinds. The algebra of models is as follows\n\nA + A = A\nM * M = M\nM * A = A\nC(A)  = A\n\nwhere A is Additive, M is Multiplicative, and C is Convolutional. All other operations are prohibited, e.g. C(M) or M * C. To obtain M * C there must be an additive component, e.g. M * C(A).\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.Additive","page":"Using models","title":"SpectralFitting.Additive","text":"Additive <: AbstractSpectralModelKind\nAdditive()\n\nAdditive models are effectively the sources of photons, and are the principle building blocks of composite models. Every additive model has a normalisation parameter which re-scales the output by a constant factor K.\n\nnote: Note\nDefining custom additive models requires special care. See Defining new models.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.Multiplicative","page":"Using models","title":"SpectralFitting.Multiplicative","text":"Multiplicative <: AbstractSpectralModelKind\nMultiplicative()\n\nMultiplicative models act on Additive models, by element-wise multiplying the output in each energy bin of the additive model by a different factor.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.Convolutional","page":"Using models","title":"SpectralFitting.Convolutional","text":"Convolutional <: AbstractSpectralModelKind\nConvolutional()\n\nConvolutional models act on the output generated by Additive models, similar to Multiplicative models, however may convolve kernels through the output also.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#Model-abstraction","page":"Using models","title":"Model abstraction","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"All spectral models are a sub-type of AbstractSpectralModel, including CompositeModel and SurrogateSpectralModel.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"AbstractSpectralModel\nSpectralFitting.invoke!\nmodelkind","category":"page"},{"location":"using-models/#SpectralFitting.AbstractSpectralModel","page":"Using models","title":"SpectralFitting.AbstractSpectralModel","text":"abstract type AbstractSpectralModel{T,K}\n\nSupertype of all spectral models. Sub-types must implement the following interface\n\nmodelkind\nSpectralFitting.invoke!\n\nThe parametric type parameter T is the number type of the model and K defines the AbstractSpectralModelKind.\n\n\n\n\n\n","category":"type"},{"location":"using-models/#SpectralFitting.invoke!","page":"Using models","title":"SpectralFitting.invoke!","text":"SpectralFitting.invoke!(output, energy, M::Type{<:AbstractSpectralModel}, params...)\n\nUsed to define the behaviour of models. Should calculate output of the model and write in-place into output.\n\nwarning: Warning\nThis function should not be called directly. Use invokemodel instead.\n\nParameters are passed in in-order as defined in the model structure. For example\n\nstruct MyModel{F1,F2,F3,...} <: AbstractSpectralModel\n    p1::F1\n    p2::F2\n    p3::F3\n    # ...\nend\n\nwould have the arguments passed to invoke! as\n\nfunction SpectralFitting.invoke!(output, energy, ::Type{<:MyModel}, p1, p2, p3, ...)\n    # ...\nend\n\nThe only exception to this are Additive models, where the normalisation parameter K is not passed to invoke!.\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.modelkind","page":"Using models","title":"SpectralFitting.modelkind","text":"modelkind(M::Type{<:AbstractSpectralModel})\nmodelkind(::AbstractSpectralModel)\n\nReturn the kind of model given by M: either Additive, Multiplicative, or Convolutional.\n\n\n\n\n\n","category":"function"},{"location":"using-models/#Model-data-availability","page":"Using models","title":"Model data availability","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Many of the XSPEC implemented models use tabular data, such as FITS, and return results interpolated from these pre-calculated tables. In some cases, these table models have data files that are multiple gigabytes in size, and would be very unwieldy to ship indiscriminantly. SpectralFitting attempts to circumnavigate this bloat by downloading the model data on an ut opus basis.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"SpectralFitting.download_model_data\nSpectralFitting.download_all_model_data","category":"page"},{"location":"using-models/#SpectralFitting.download_model_data","page":"Using models","title":"SpectralFitting.download_model_data","text":"SpectralFitting.download_model_data(model::AbstractSpectralModel; kwargs...)\nSpectralFitting.download_model_data(M::Type{<:AbstractSpectralModel}; kwargs...)\nSpectralFitting.download_model_data(s::Symbol; kwargs...)\n\nDownloads the model data for a model specified either by model, type M, or symbol s. Datafiles associated with a specific model may be registered using SpectralFitting.register_model_data. The download is currently unconfigurable, but permits slight control via a number of keyword arguments:\n\nprogress::Bool = true\n\nDisplay a progress bar for the download.\n\nmodel_source_url::String = \"http://www.star.bris.ac.uk/fbaker/XSPEC-model-data\"\n\nThe source URL used to download the model data.\n\nAll standard XSPEC spectral model data is currently being hosted on the University of Bristol astrophysics servers, and should be persistently available to anyone.\n\n\n\n\n\n","category":"function"},{"location":"using-models/#SpectralFitting.download_all_model_data","page":"Using models","title":"SpectralFitting.download_all_model_data","text":"SpectralFitting.download_all_model_data()\n\nDownloads all model data for the models currently registered with SpectralFitting.register_model_data. Calls SpectralFitting.download_model_data to perform the download.\n\n\n\n\n\n","category":"function"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Special care must be taken if new XSPEC models are wrapped to ensure the data is available. For more on this, see Wrapping new XSPEC models.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Model data may also alternatively be copied in by-hand from a HEASoft XSPEC source directory. In this case, the location to copy the data to may be determined via joinpath(SpectralFitting.LibXSPEC_jll.artifact_dir, \"spectral\", \"modelData\").","category":"page"},{"location":"using-models/#Instantiating-and-invoking-models","page":"Using models","title":"Instantiating and invoking models","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"Models may be composed together to create more complex spectra, with the algebra defined by the AbstractSpectralModelKind. ","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"For example, a XS_PowerLaw model may multiply element-wise by a XS_PhotoelectricAbsorption model:","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"model = XS_PhotoelectricAbsorption() * XS_PowerLaw()\nmodel","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"A model may be evaluated by using invokemodel:","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"energy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, model)","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"note: Note\nXSPEC models are implemented to accept a single energy vector with all of the low and high energy bin edges, and return a flux array with the flux in each energy bin. For consistency, SpectralFitting implement models in the same way, and therefore it is always the case that:length(flux) == length(energy) - 1","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"invokemodel\ninvokemodel!","category":"page"},{"location":"using-models/#SpectralFitting.invokemodel","page":"Using models","title":"SpectralFitting.invokemodel","text":"invokemodel(energy, model)\ninvokemodel(energy, model, free_params)\n\nInvoke the AbstractSpectralModel given by model, optionally overriding the free parameters with values given in free_params. free_params may be a vector or tuple with element type FitParam or Number.\n\nThis function, unlike SpectralFitting.invoke! used to define models, is sensitive to performing any normalisation or post-processing tasks that a specific model kind may require.\n\nnote: Note\nUsers should always call models using invokemodel or invokemodel! to ensure normalisations and closures are accounted for.\n\ninvokemodel allocates the needed output arrays based on the element type of free_params to allow automatic differentation libraries to calculate parameter gradients.\n\nIn-place non-allocating variants are the invokemodel! functions.\n\nExample\n\nmodel = XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, model)\n\np0 = [0.1, 2.0] # change K and a\ninvokemodel(energy, model, p0)\n\n\n\n\n\n","category":"function"},{"location":"using-models/#Utilities","page":"Using models","title":"Utilities","text":"","category":"section"},{"location":"using-models/","page":"Using models","title":"Using models","text":"SpectralFitting defines a number of utility functions for model introspection and manipulation.","category":"page"},{"location":"using-models/","page":"Using models","title":"Using models","text":"flux_count\nget_param\nget_param_count\nget_param_types\nget_param_symbols\nget_param_symbol_pairs\nget_params\nget_params_value","category":"page"},{"location":"composite-models/#Composite-models","page":"Composite models","title":"Composite models","text":"","category":"section"},{"location":"composite-models/","page":"Composite models","title":"Composite models","text":"The model algebra defined by the AbstractSpectralModelKind yields instances of CompositeModel, nested to various degrees. These composite models are designed to make as much information about the spectral model available at compile-time, such that rich and optimized generated functions may be assembled purely from the Julia types (see Why & how).","category":"page"},{"location":"composite-models/","page":"Composite models","title":"Composite models","text":"CompositeModel\nAbstractCompositeOperator\nAdditionOperator\nMultiplicationOperator\nConvolutionOperator\noperation_symbol","category":"page"},{"location":"composite-models/#SpectralFitting.CompositeModel","page":"Composite models","title":"SpectralFitting.CompositeModel","text":"CompositeModel{M1,M2,O} <: AbstractSpectralModel\nCompositeModel(left_model, right_model, op::AbstractCompositeOperator)\n\nType resulting from operations combining any number of AbstractSpectralModel via the model algebra defined from AbstractSpectralModelKind.\n\nEach operation binary operation in the model algebra is encoded in the parametric types of the CompositeModel, where the operation is given by an AbstractCompositeOperator. Composite models adopt the model kind of the right model, i.e. M2, and obey the model algebra accordingly.\n\nComposite models very rarely need to be constructed directly, and are instead obtained by regular model operations.\n\nExample\n\nmodel = XS_PhotoelectricAbsorption() * (XS_PowerLaw() + XS_BlackBody())\ntypeof(model) <: CompositeModel # true\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.AbstractCompositeOperator","page":"Composite models","title":"SpectralFitting.AbstractCompositeOperator","text":"abstract type AbstractCompositeOperator\n\nSuperype of all composition operators. Used to implement the model algebra of AbstractSpectralModelKind through a trait system.\n\nThe Julia symbol corresponding to a given AbstractCompositeOperator may be obtained through operation_symbol.\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.AdditionOperator","page":"Composite models","title":"SpectralFitting.AdditionOperator","text":"AdditionOperator <: AbstractCompositeOperator\nAdditionOperator()\n\nCorresponds to the :(+) symbol.\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.MultiplicationOperator","page":"Composite models","title":"SpectralFitting.MultiplicationOperator","text":"MultiplicationOperator <: AbstractCompositeOperator\nMultiplicationOperator()\n\nCorresponds to the :(*) symbol.\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.ConvolutionOperator","page":"Composite models","title":"SpectralFitting.ConvolutionOperator","text":"ConvolutionOperator <: AbstractCompositeOperator\nConvolutionOperator()\n\nHas no corresponding symbol, since it invokes a function call C(A).\n\n\n\n\n\n","category":"type"},{"location":"composite-models/#SpectralFitting.operation_symbol","page":"Composite models","title":"SpectralFitting.operation_symbol","text":"operation_symbol(::AbstractCompositeOperator)\noperation_symbol(::Type{<:AbstractCompositeOperator})\n\nObtain the model symbol from a given AbstractCompositeOperator.\n\n\n\n\n\n","category":"function"},{"location":"models/#Models-index","page":"Model index","title":"Models index","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"Models wrapped from XSPEC implementations are prefixed with XS_*, whereas pure-Julia models are simply named, e.g. XS_PowerLaw in XSPEC vs PowerLaw in Julia.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"The available models are","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"Pages = [\"models.md\"]\nOrder = [:type]","category":"page"},{"location":"models/#Julia-models","page":"Model index","title":"Julia models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"PowerLaw\nBlackBody","category":"page"},{"location":"models/#SpectralFitting.PowerLaw","page":"Model index","title":"SpectralFitting.PowerLaw","text":"XS_PowerLaw(K, a)\n\nK: Normalisation.\na: Photon index.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, PowerLaw())\n\n                        PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.BlackBody","page":"Model index","title":"SpectralFitting.BlackBody","text":"XS_BlackBody(K, T)\n\nK: Normalisation.\nkT: Temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, BlackBody())\n\n                        BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │     :'      '':.                       │\n       │   .'           ':.                     │\n       │  .:               '..                  │\n       │  :                  ':.                │\n       │ .'                     ':..            │\n       │ :                         ''...        │\n       │:                              '''....  │\n     0 │:                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#Defining-new-models","page":"Model index","title":"Defining new models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"To define a new Julia model, we need only implement the AbstractSpectralModel interface. As a pedagogical example, consider an implementation of PowerLaw:","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"# define the model and parameters\n@with_kw struct PowerLaw{F1,F2} <: AbstractSpectralModel\n    \"Normalisation.\"\n    K::F1 = FitParam(1.0)\n    \"Photon index.\"\n    a::F2 = FitParam(0.5)\nend\n\n# tell the package what kind of model this is\nmodelkind(::Type{<:PowerLaw}) = Additive()\n\n# define how the model acts: \n# all of the parameters are passed, in order, as arguments\nfunction SpectralFitting.invoke!(flux, energy, ::Type{<:PowerLaw}, a)\n    α = 1 - a\n    α⁻¹ = inv(α)\n    SpectralFitting.finite_diff_kernel!(flux, energy) do E\n        α⁻¹ * E^α\n    end\nend","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"Note that each parameter has its own parametric type, here ::F1 and ::F2. This is so that the type of fit parameters can be changed, or alternative number types inserted (see Why & how). The standard parameter type is FitParam, which is what we have used here.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"The model is defined to be additive by overloading modelkind.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"danger: Danger\nAdditive models must have a normalisation parameter with the symbol K, which is, however, not passed to SpectralFitting.invoke!. Multiplicative and convolutional models have no such requirements.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"We have also used the SpectralFitting.finite_diff_kernel! utility function, which is designed to help us efficiently compute finite-difference integrations of flux, just as XSPEC does.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"note: Note\nTo add additional XSPEC models, see Wrapping new XSPEC models.","category":"page"},{"location":"models/#XSPEC-models","page":"Model index","title":"XSPEC models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"XSPEC models frequently have tabular data dependencies, without which the models fail to invoke (see Model data availability). If the data files are known but not present, the XSPEC models will throw an error with instructions for downloading the missing data. If the data files are unknown, Julia may crash catastrophically. If this is the case, often a single line will be printed with the LibXSPEC error, specifying the name of the missing source file. This can be registered as a data dependency of a model using SpectralFitting.register_model_data.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"The first time any XSPEC model is invoked, SpectralFitting checks to see whether requisite data is needed, and whether the data is downloaded. Subsequent calls will hit a lookup cache instead to avoid run-time costs of performing this check.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"XS_PowerLaw\nXS_BlackBody\nXS_BremsStrahlung\nXS_Gaussian\nXS_Laor\nXS_DiskLine\nXS_PhotoelectricAbsorption\nXS_WarmAbsorption\nXS_CalculateFlux\nXS_KerrDisk\nXS_KyrLine","category":"page"},{"location":"models/#SpectralFitting.XS_PowerLaw","page":"Model index","title":"SpectralFitting.XS_PowerLaw","text":"XS_PowerLaw(K, a)\n\nK: Normalisation.\na: Photon index.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PowerLaw())\n\n                      XS_PowerLaw\n       ┌────────────────────────────────────────┐\n   0.5 │                                        │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │:                                       │\n       │ :                                      │\n       │ :                                      │\n       │  :                                     │\n       │   :.                                   │\n       │    ':..                                │\n       │        ''':......                      │\n       │                  ''''''''''''''........│\n     0 │                                        │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_BlackBody","page":"Model index","title":"SpectralFitting.XS_BlackBody","text":"XS_BlackBody(K, T)\n\nK: Normalisation.\nT: Temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BlackBody())\n\n                      XS_BlackBody\n       ┌────────────────────────────────────────┐\n   0.2 │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │                                        │\n       │      .:''':..                          │\n       │    .:       ''.                        │\n       │   .'           ':.                     │\n       │   :              ''..                  │\n       │  :                  ':.                │\n       │ :                     '':.             │\n       │.:                         ''..         │\n       │:                              '':....  │\n     0 │'                                    '''│\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_BremsStrahlung","page":"Model index","title":"SpectralFitting.XS_BremsStrahlung","text":"XS_BremsStrahlung(K, T)\n\nK: Normalisation.\nT: Plasma temperature (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_BremsStrahlung())\n\n                  XS_BremsStrahlung\n     ┌────────────────────────────────────────┐\n   2 │                                        │\n     │.                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │:                                       │\n     │'.                                      │\n     │ :                                      │\n   0 │  ':....................................│\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_Gaussian","page":"Model index","title":"SpectralFitting.XS_Gaussian","text":"XS_Gaussian(K, E, σ)\n\nK: Normalisation\nE: Line wavelength in Angstrom.\nσ: Line width in Angstrom.\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_Gaussian())\n\n                        XS_Gaussian                \n        ┌────────────────────────────────────────┐ \n   0.09 │                                        │ \n        │            .                           │ \n        │           : :                          │ \n        │           : :                          │ \n        │           : '.                         │ \n        │          .'  :                         │ \n        │          :   :                         │ \n        │          :   :                         │ \n        │          :   '.                        │ \n        │         :     :                        │ \n        │         :     :                        │ \n        │         :     :                        │ \n        │        .'      :                       │ \n        │        :       :                       │ \n      0 │.......:         :......................│ \n        └────────────────────────────────────────┘ \n         0                                     20  \n                          E (keV)                  \n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_Laor","page":"Model index","title":"SpectralFitting.XS_Laor","text":"XS_Laor(K, lineE, a, inner_r, outer_r, incl)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\na: Power law dependence of emissitivy. Scales R⁻ᵅ.\ninner_r: Inner radius of the accretion disk (GM/c).\nouter_r: Outer radius of the accretion disk (GM/c).\nθ: Disk inclination angle to line of sight (degrees, 0 is pole on).\n\nExample\n\nenergy = collect(range(0.1, 10.0, 100))\ninvokemodel(energy, XS_Laor())\n\n                          XS_Laor\n        ┌────────────────────────────────────────┐\n   0.06 │                                        │\n        │                                        │\n        │                         ::             │\n        │                         ::             │\n        │                        : :             │\n        │                       :  :             │\n        │                      :   :             │\n        │                     :'   :             │\n        │                   .:     :             │\n        │                  :'      :             │\n        │                .'        :             │\n        │              .:'         :             │\n        │            ..'           :             │\n        │          .:'              :            │\n      0 │.......:''                 :............│\n        └────────────────────────────────────────┘\n         0                                     10\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_DiskLine","page":"Model index","title":"SpectralFitting.XS_DiskLine","text":"XS_DiskLine(K, lineE, β, inner_r, outer_r, incl)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\nβ: Power law dependence of emissitivy. If < 10, scales Rᵅ.\ninner_r: Inner radius of the accretion disk (GM/c).\nouter_r: Outer radius of the accretion disk (GM/c).\nθ: Disk inclination angle to line of sight (degrees, 0 is pole on).\n\nExample\n\nenergy = collect(range(4.0, 8.0, 100))\ninvokemodel(energy, XS_DiskLine())\n\n                        XS_DiskLine\n        ┌────────────────────────────────────────┐\n   0.09 │                                        │\n        │                           .            │\n        │                           :            │\n        │                           ::           │\n        │                         . ::           │\n        │                         : ::           │\n        │                         :'':           │\n        │                        .'  :           │\n        │                        :    :          │\n        │                        :    :          │\n        │                       .'    :          │\n        │                       :     :          │\n        │                     .:      '.         │\n        │                   .:'        :         │\n      0 │...............:'''           :.........│\n        └────────────────────────────────────────┘\n         4                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_PhotoelectricAbsorption","page":"Model index","title":"SpectralFitting.XS_PhotoelectricAbsorption","text":"XS_PhotoelectricAbsorption(ηH)\n\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_PhotoelectricAbsorption())\n\n             XS_PhotoelectricAbsorption\n     ┌────────────────────────────────────────┐\n   1 │       ...''''''''''''''''''''''''''''''│\n     │      .'                                │\n     │     :                                  │\n     │    :'                                  │\n     │    :                                   │\n     │   :                                    │\n     │   :                                    │\n     │   :                                    │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │  :                                     │\n     │ :                                      │\n   0 │.:                                      │\n     └────────────────────────────────────────┘\n      0                                     20\n                       E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_WarmAbsorption","page":"Model index","title":"SpectralFitting.XS_WarmAbsorption","text":"XS_WarmAbsorption(ηH, Ew)\n\nηH: Equivalent hydrogen column (units of 10²² atoms per cm⁻²).\nEw: Window energy (keV).\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_WarmAbsorption())\n\n                    XS_WarmAbsorption\n       ┌────────────────────────────────────────┐\n     1 │':      ...''':'''''''''''''''''''''''''│\n       │ :    .:'                               │\n       │ :   .'                                 │\n       │ :  .:                                  │\n       │ :  :                                   │\n       │ :  :                                   │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ : :                                    │\n       │ ::                                     │\n       │ ::                                     │\n       │  :                                     │\n       │  :                                     │\n   0.2 │  :                                     │\n       └────────────────────────────────────────┘\n        0                                     20\n                         E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_CalculateFlux","page":"Model index","title":"SpectralFitting.XS_CalculateFlux","text":"XS_CalculateFlux(E_min, E_max, lg10Flux)\n\nE_min: Minimum energy.\nE_max: Maximum energy.\nlog10Flux: log (base 10) flux in erg / cm^2 / s\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_KerrDisk","page":"Model index","title":"SpectralFitting.XS_KerrDisk","text":"XS_KerrDisk(K, lineE, index1, index2, break_r, a, θ, inner_r, outer_r)\n\nK: Normalisation.\nlineE: Rest frame line energy (keV).\nindex1: Emissivity index for inner disk.\nindex2: Emissivity index for outer disk.\nbreak_r: Break radius seperating inner and outer disk (gᵣ).\na: Dimensionless black hole spin.\nθ: Disk inclination angle to line of sight (degrees).\ninner_r: Inner radius of the disk in units of rₘₛ.\nouter_r: Outer radius of the disk in units of rₘₛ.\nz: Redshift.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KerrDisk())\n\n                        XS_KerrDisk\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                .       │\n        │                               .:       │\n        │                              :::       │\n        │                            .:' '.      │\n        │                           .:    :      │\n        │                         ..'     :      │\n        │                         :'      :      │\n        │                       .'        :      │\n        │                     .:'         :      │\n        │                  .:''           :      │\n        │               .::'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#SpectralFitting.XS_KyrLine","page":"Model index","title":"SpectralFitting.XS_KyrLine","text":"XS_KyrLine(K, a, θ_obs, inner_r, ms_flag, outer_r, lineE, α, β, break_r, z, limb)\n\nK: Normalisation.\na: Dimensionless black hole spin.\nθ: Observer inclination (0 is on pole, degrees).\ninner_r: Inner radius of the disk in units of GM/c²\nms_flag: 0: integrate from rᵢₙ. 1: integrate from rₘₛ.\nouter_r: Outer radius of the disk in units of GM/c²\nlineE: Rest frame line energy (keV).\nα\nβ\nbreak_r: Break radius seperating inner and outer disk (GM/c²).\nz: Overall Doppler shift.\nlimb: 0: isotropic emission, 1: Laor's limb darkening, 2: Haard's limb brightening.\n\nExample\n\nenergy = collect(range(0.1, 20.0, 100))\ninvokemodel(energy, XS_KyrLine())\n\n                        XS_KyrLine\n        ┌────────────────────────────────────────┐\n   0.05 │                                        │\n        │                                        │\n        │                                :       │\n        │                                :.      │\n        │                              :.':      │\n        │                             :'  :      │\n        │                            :    :      │\n        │                          .'     :      │\n        │                        .:'      :      │\n        │                       .'        :      │\n        │                     .:          :      │\n        │                   .'            :      │\n        │                .:'              :      │\n        │            ..:'                 :      │\n      0 │.........:'''                    :......│\n        └────────────────────────────────────────┘\n         0                                      8\n                          E (keV)\n\n\n\n\n\n","category":"type"},{"location":"models/#Wrapping-new-XSPEC-models","page":"Model index","title":"Wrapping new XSPEC models","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"SpectralFitting exports a helpful macro to facilitate wrapping additional XSPEC models.","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"@xspecmodel\nSpectralFitting.register_model_data","category":"page"},{"location":"models/#SpectralFitting.@xspecmodel","page":"Model index","title":"SpectralFitting.@xspecmodel","text":"@xspecmodel [type=Float64] [ff_call_site] model\n\nUsed to wrap additional XSPEC models, generating the needed AbstractSpectralModel implementation.\n\nThe type keyword specifies the underlying type to coerce input and output arrays to, as different implementations may have incompatible number of bits. The ff_call_site is the foreign fuction call site, which is the first argument to ccall, and follows the same conventions. The model is a struct, which must subtype AbstractSpectralModel.\n\nIf the callsite is not specified, the user must implement _unsafe_ffi_invoke!.\n\nExamples\n\n@xspecmodel :C_powerlaw struct XS_PowerLaw{T} <: AbstractSpectralModel{T, Additive}\n    \"Normalisation.\"\n    K::T\n    \"Photon index.\"\n    a::T\nend\n\n# constructor has default values\nfunction XS_PowerLaw(; K = FitParam(1.0), a = FitParam(1.0))\n    XS_PowerLaw{typeof(K)}(K, a)\nend\n\nWe define a new structure XS_PowerLaw with two parameters, but since the model is Additive, only a single parameter (a) is passed to the XSPEC function. The function we bind to this model is :C_powerlaw from the XSPEC C wrappers.\n\nThe macro will then generate the following functions\n\nimplementation \ninvoke! \n_safe_ffi_invoke! \n\nIf a callsite was specified, it will also generate:\n\n_unsafe_ffi_invoke! \n\n\n\n\n\n","category":"macro"},{"location":"models/#SpectralFitting.register_model_data","page":"Model index","title":"SpectralFitting.register_model_data","text":"SpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, model_data::ModelDataInfo...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, remote_and_local::Tuple{String,String}...)\nSpectralFitting.register_model_data(M::Type{<:AbstractSpectralModel}, filenames::String...)\nSpectralFitting.register_model_data(s::Symbol, filenames::String...)\n\nRegister filenames as model data associated with the model given by type M or symbol s. This function does not download any files, but rather adds the relevant filenames to a lookup which SpectralFitting.download_model_data consults when invoked, and consequently model data is only downloaded when needed.\n\nnote: Note\nIt is good practice to use this method immediately after defining a new model with @xspecmodel to register any required datafiles from the HEASoft source code, and therefore keep relevant information together.\n\nExample\n\n# by type\nregister_model_data(XS_Laor, \"ari.mod\")\n# by symbol\nregister_model_data(:XS_KyrLine, \"KBHline01.fits\")\n\n\n\n\n\n","category":"function"},{"location":"models/#Generating-model-fingerprints","page":"Model index","title":"Generating model fingerprints","text":"","category":"section"},{"location":"models/","page":"Model index","title":"Model index","text":"To generate the unicode plot to add as a fingerprint, we use a simple function:","category":"page"},{"location":"models/","page":"Model index","title":"Model index","text":"using SpectralFitting, UnicodePlots\n\nfunction plotmodel(energy, model)\n    flux = invokemodel(energy, model)\n    lineplot(\n        energy[1:end-1], \n        flux, \n        title=String(SpectralFitting.FunctionGeneration.model_base_name(typeof(model))), \n        xlabel=\"E (keV)\", \n        canvas=DotCanvas\n    )\nend\n\n# e.g. for XS_PowerLaw()\nenergy = collect(range(0.1, 20.0, 100))\nplotmodel(energy, XS_PowerLaw())","category":"page"},{"location":"why-and-how/#Why-and-how","page":"Why & How","title":"Why & how","text":"","category":"section"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"SpectralFitting.jl is a package for fitting models to spectral data, similar to XSPEC, Sherpa or ISIS.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"The rationale for this package is to provide a unanimous interface for different model libraries, and to leverage the bleeding edge advancements in computing that are available in Julia, including the rich statistics ecosystem, with automatic-differentiation and speed.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"SpectralFitting aims to provide highly optimised and flexible fitting algorithms, along with a library of spectral models, for use in any field of Astronomy that concerns itself with spectral data.","category":"page"},{"location":"why-and-how/#Rewriting-model-calls-during-invocation","page":"Why & How","title":"Rewriting model calls during invocation","text":"","category":"section"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"using SpectralFitting","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"SpectralFitting.jl tries to optimise model invocation through source-rewriting. For compatibility with the XSPEC model library, this is achieved through aggressive pre-allocation and shuffling of output vectors. All XSPEC models output the result of their calculation through side effects into a flux array passed as an argument, and therefore each model invocation requires its own output before addition or multiplication of fluxes may occur.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Principally, combining several models together would look like this:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"energy = collect(range(0.1, 20.0, 100))\n\nflux1 = invokemodel(energy, XS_PowerLaw())\nflux2 = invokemodel(energy, XS_PowerLaw(a=FitParam(3.0)))\nflux3 = invokemodel(energy, XS_BlackBody())\nflux4 = invokemodel(energy, XS_PhotoelectricAbsorption())\n\ntotal_flux = @. flux4 * (flux1 + flux2 + flux3)\nsum(total_flux)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"But these operations could also be performed in a different order:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"flux1 = invokemodel(energy, XS_PowerLaw())\nflux2 = invokemodel(energy, XS_PowerLaw(a=FitParam(3.0)))\ntotal_flux = @. flux1 + flux2\n\nflux3 = invokemodel(energy, XS_BlackBody())\n@. total_flux = total_flux + flux3\n\nflux4 = invokemodel(energy, XS_PhotoelectricAbsorption())\n@. total_flux = total_flux * flux4\nsum(total_flux)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Doing so would allow us to only pre-allocate 2 flux arrays, instead of 4 when using the in-place variants:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"fluxes = SpectralFitting.construct_objective_cache(model, energy)\nflux1, flux2 = eachcol(fluxes)\n\ninvokemodel!(flux1, energy, XS_PowerLaw())\ninvokemodel!(flux2, energy, XS_PowerLaw(a=FitParam(3.0)))\n@. flux1 = flux1 + flux2\n\ninvokemodel!(flux2, energy, XS_BlackBody())\n@. flux1 = flux1 + flux2\n\ninvokemodel!(flux2, energy, XS_PhotoelectricAbsorption())\n@. flux1 = flux1 * flux2\nsum(flux1)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"It is precisely this re-writing that SpectralFitting performs via @generated functions. We can inspect the code used to generate the invocation body after defining a CompositeModel:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"model = XS_PhotoelectricAbsorption() * (\n    XS_PowerLaw() + XS_PowerLaw(a=FitParam(3.0)) + XS_BlackBody()\n)\n\nparams = get_value.(SpectralFitting.model_parameters_tuple(model))\nSpectralFitting.FunctionGeneration.generated_model_call!(typeof(fluxes), typeof(energy), typeof(model), typeof(params))","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"This generated function also takes care of some other things for us, such as unpacking parameters (optionally unpacking frozen parameters separately), and ensuring any closure are passed to invokemodel if a model needs them (e.g., SurrogateSpectralModel).","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"This is achieved by moving as much information as possible about the model and its construction to its type, such that all of the invocation and parameter unpacking may be inferred at compile time.","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"Naturally, the CompositeModel types also support the out-of-place invokemodel and will allocate the minimum number of flux arrays needed, inferred using flux_count:","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"flux = invokemodel(energy, model)\nsum(flux)","category":"page"},{"location":"why-and-how/","page":"Why & How","title":"Why & How","text":"note: Note\nWith the addition of more pure-Julia models, non-allocating methods without aggressive pre-allocation are possible, and will be added in the future. Such methods may allow models to add or multiply in-place on the total flux array, instead of relying on later broadcasts.","category":"page"},{"location":"fitting/#Fitting-spectral-models","page":"Fitting spectral models","title":"Fitting spectral models","text":"","category":"section"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Energy-and-flux-utility-functions","page":"Reference","title":"Energy and flux utility functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"make_flux\nmake_fluxes","category":"page"},{"location":"reference/#Utility-functions-for-defining-new-models","page":"Reference","title":"Utility functions for defining new models","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"SpectralFitting.finite_diff_kernel!\nwrap_model_as_objective","category":"page"},{"location":"reference/#SpectralFitting.finite_diff_kernel!","page":"Reference","title":"SpectralFitting.finite_diff_kernel!","text":"finite_diff_kernel!(f::Function, flux, energy)\n\nCalculates the finite difference of the function f over the energy bin between the high and low bin edges, via\n\nc_i = f(E_itexthigh) - f(E_itextlow)\n\nsimilar to evaluating the limits of the integral between E_itexthigh and E_itextlow.\n\nThis utility function is primarily used for Additive models to ensure the flux per bin is normalised for the energy over the bin.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Introspection","page":"Reference","title":"Introspection","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"has_closure_params\nget_closure_param_fields\nmodel_base_name","category":"page"},{"location":"walkthrough/#Walkthrough","page":"Walkthrough","title":"Walkthrough","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"warning: Warning\nThis walk through has not been fleshed out with the relevant astrophysical content yet (for example, whether a fit is good, what the different parameters mean, etc.), and so assumes some familarity with spectral fitting in general.It is also not yet complete, nor a faithful illustration of everything SpectralFitting.jl can do. It serves to illustrate similarities and differences in syntax between SpectralFitting.jl and XSPEC.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"This example walkthrough is the SpectralFitting.jl equivalent of the Walk through XSPEC from the XSPEC manual. We will use the same dataset, available for download from this link to the data files.","category":"page"},{"location":"walkthrough/#Overview","page":"Walkthrough","title":"Overview","text":"","category":"section"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The first thing we want to do is load our datasets. Unlike in XSPEC, we have no requirement of being in the same directory as the data, or even that all of the response, ancillary, and spectral files be in the same place. For simplicity, we'll assume they are:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nBe sure to set DATADIR pointing to the directory where you keep the walkthrough data.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"using SpectralFitting, Plots\n\nDATADIR = \"...\"\nDATADIR = length(get(ENV, \"CI\", \"\")) > 0 ? @__DIR__() * \"/../../ex-datadir\" : \"/home/lilith/Developer/jl/datasets/xspec/walkthrough\" # hide\nspec1_path = joinpath(DATADIR, \"s54405.pha\")\ndata = OGIPDataset(spec1_path) ","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"This will print a little card about our data, which shows us what else SpectralFitting.jl loaded. We can see the Primary Spectrum, the Response, but that the Background and Ancillary response files are missing. That's to be expected, since we don't have those files in the dataset. ","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can check what paths it used by looking at","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"data.paths","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can load and alter any part of a dataset as we do our fitting. For example, if you have multiple different ancillary files at hand, switching them between fits is a one-liner.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"To visualize our data, we can use some of the Plots.jl recipes included in SpectralFitting.jl:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, xlims = (0.5, 70), xscale = :log10)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Note that the units are currently not divided by the energy bin widths. We can either do that manually, or use the normalize! to convert whatever units the data is currently in to the defacto standard counts s⁻¹ keV⁻¹ for fitting. Whilst we're at it, we see in the model card that there are 40 bad quality bins still present in our data. We can drop those as well, and plot the data on log-log axes:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"normalize!(data)\ndrop_bad_channels!(data)\nplot(data, ylims = (0.001, 2.0), yscale = :log10, xscale = :log10)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Note that when there are no negative axes, the scale defaults to log on the plot unless otherwise specified.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Next we want to specify a model to fit to this data. Models that are prefixed with XS_ are models that are linked from the XSPEC model library, provided via LibXSPEC_jll. For a full list of the models, see Models library.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"warning: Warning\nIt is advised to use the Julia implemented models. This allows various calculations to benefit from automatic differentiation, efficient multi-threading, GPU offloading, and various other useful things, see Why & how.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We will start by fitting a photoelectric absorption model that acts on a power law model:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nTo see information about a model, use the ? in the Julia REPL:julia> ?PowerLaw\nXS_PowerLaw(K, a)\n\n    •  K: Normalisation.\n\n    •  a: Photon index.\n\nExample\n≡≡≡≡≡≡≡\n...","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model = PhotoelectricAbsorption() * PowerLaw()","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"If we want to specify paramters of our model at instantiation, we can do that with","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model = PhotoelectricAbsorption() * PowerLaw(a = FitParam(3.0))","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"SpectralFitting.jl adopts the SciML problem-solver abstraction, so to fit a model to data we specify a FittingProblem:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"prob = FittingProblem(model => data)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"SpectralFitting.jl makes a huge wealth of optimizers availble from Optimizations.jl, and others from further afield. For consistency with XSPEC, we'll use here a delayed-gratification least-squares algorithm from LsqFit.jl:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"result = fit(prob, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Here we can see the parameter vector, the estimated error on each parameter, and the measure of the fit statistic (here chi squared). We can overplot our result on our data easily:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(data, result)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Our model does not account for the high energy range well. We can ignore that range for now, and select everything from 0 to 15 keV and refit:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"mask_energies!(data, 0, 15)\nresult = fit(prob, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(data, result, label = \"PowerLaw\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The result is not yet baked into our model, and represents just the outcome of the fit. To update the parameters and errors in the model, we can use update_model!","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"update_model!(model, result)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nSince fitting and updating a model is often done in tandem, SpectralFitting.jl has both a fit and fit! method, the latter automatically updates the model parameters after fit.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"To estimate the goodness of our fit, we can mimic the goodness command from XSPEC. This will use the simulate function to simulate spectra for a dataset (here determined by the result), and fit the model to the simulated dataset. The fit statistic for each fit is then appended to an array, which we can use to plot a histogram:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"spread = goodness(result; N = 1000, seed = 42, exposure_time = data.data.spectrum.exposure_time)\nhistogram(spread, ylims = (0, 300), label = \"Simulated\")\nvline!([result.χ2], label = \"Best fit\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Note we have set the random number generator seed with seed = 42 to allow our results to be strictly reproduced.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"The goodness command will log the percent of simulations with a fit statistic better than the result, but we can equivalently calculate that ourselves:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"count(<(result.χ2), spread) * 100 / length(spread)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Next we want to calculate the flux in an energy range observed by the detector. We can do this with LogFlux or XS_CalculateFlux, as they are both equivalent implementations.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can modify our model by accessing properties from the model card and writing a new expression:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"calc_flux = XS_CalculateFlux(\n    E_min = FitParam(0.2, frozen = true), \n    E_max = FitParam(2.0, frozen = true),\n    log10Flux = FitParam(-10.3, lower_limit = -100, upper_limit = 100),\n)\n\nflux_model = model.m1 * calc_flux(model.a1)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Since we used the old model to define the new one, our best fit values are automatically copied into the new model. We can now freeze the normalization, as we are using the flux integrating model to scale the powerlaw component:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"flux_model.a1.K.frozen = true\nflux_model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Looking at the data card, we see the fit domain does not include the full region that we want to integrate the flux over. We therefore need to extend the fitting domain:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"flux_problem = FittingProblem(flux_model => data)\n# TODO: domain extensions not fully implemented yet","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Now to fit we can repeat the above procedure, and even overplot the region of flux we integrated:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"flux_result = fit(flux_problem, LevenbergMarquadt())\n\nplot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10\n)\nplot!(data, flux_result)\nvspan!([flux_model.c1.E_min.value, flux_model.c1.E_max.value], alpha = 0.5)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's try alternative models to see how they fit the data. First, an absorbed black body:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model2 = PhotoelectricAbsorption() * XS_BlackBody()","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We fit in the same way as before:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"prob2 = FittingProblem(model2 => data)\nresult2 = fit!(prob2, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's overplot this result against our power law result:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"dp = plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10,\n    legend = :bottomleft,\n)\nplot!(dp, data, result, label = \"PowerLaw $(round(result.χ2))\")\nplot!(dp, data, result2, label = \"BlackBody $(round(result2.χ2))\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Or a bremsstrahlung model:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"model3 = PhotoelectricAbsorption() * XS_BremsStrahlung()\nprob3 = FittingProblem(model3 => data)\nresult3 = fit(prob3, LevenbergMarquadt())","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot!(dp, data, result3, label = \"Brems $(round(result3.χ2))\")","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's take a look at the residuals of these three models. There are utility methods for this in SpectralFitting.jl, but we can easily just interact with the result directly:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"function residuals(result)\n    # select which result we want (only have one, but for generalisation to multi-model fits)\n    r = result[1] \n    y = invoke_result(r)\n    @. (r.objective - y) / sqrt(r.variance)\nend\n\ndomain = SpectralFitting.plotting_domain(data)\n\nrp = hline([0], linestyle = :dash, legend = false)\nplot!(rp,domain, residuals(result), seriestype = :stepmid)\nplot!(rp, domain, residuals(result2), seriestype = :stepmid)\nplot!(rp, domain, residuals(result3), seriestype = :stepmid)\nrp","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We can compose this figure with our previous one, and change to a linear x scale:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(dp, rp, layout = grid(2, 1, heights = [0.7, 0.3]), link = :x, xscale = :linear)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's modify the black body model with a continuum component","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_model = model2.m1 * (PowerLaw() + model2.a1) |> deepcopy","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"note: Note\nWe pipe the model to deepcopy to create a copy of all the model parameters. Not doing this means the parameters in bbpl_model will be aliased to the parameters in model2, and changing one with change the other.","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"We'll freeze the hydrogen column density parameter to the galactic value and refit:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_model.ηH_1.value = 4\nbbpl_model.ηH_1.frozen = true\nbbpl_model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"And fitting:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_result = fit(\n    FittingProblem(bbpl_model => data), \n    LevenbergMarquadt()\n)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Let's plot the result:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot(data, \n    ylims = (0.001, 2.0), \n    xscale = :log10, \n    yscale = :log10,\n    legend = :bottomleft,\n)\nplot!(data, bbpl_result)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Update the model and fix the black body temperature to 2 keV:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"update_model!(bbpl_model, bbpl_result)\n\nbbpl_model.T_1.value = 2.0\nbbpl_model.T_1.frozen = true\nbbpl_model","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Fitting:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"bbpl_result2 = fit(\n    FittingProblem(bbpl_model => data), \n    LevenbergMarquadt()\n)","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"Overplotting this new result:","category":"page"},{"location":"walkthrough/","page":"Walkthrough","title":"Walkthrough","text":"plot!(data, bbpl_result2)","category":"page"},{"location":"examples/#Spectral-fitting-examples","page":"Examples","title":"Spectral fitting examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SpectralFitting\nusing Plots\nENV[\"GKSwstype\"]=\"nul\"\nPlots.default(show=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below are a number of examples illustrating how this package may be used.","category":"page"},{"location":"examples/#Using-the-model-library","page":"Examples","title":"Using the model library","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The model library details a model algebra (see AbstractSpectralModelKind) for composing models together. An example use of this may be to construct a complex model from a series of simpler models, and invoke the models on a given energy grid:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SpectralFitting\nusing Plots \n\nmodel = PhotoelectricAbsorption() * (PowerLaw() + BlackBody()) \n\n# define energy grid\nenergy = collect(range(0.1, 12.0, 100))\n\nflux = invokemodel(energy, model)\n\nplot(energy[1:end-1], flux)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note this energy grid may be arbitrarily spaced, but, like XSPEC, assumes the bins are contiguous, i.e. that the high energy limit of one bin is the low energy limit of the next.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The full model library of available models is listed in Model index.","category":"page"},{"location":"#SpectralFitting.jl-Documentation","page":"Home","title":"SpectralFitting.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast and flexible spectral fitting in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting.jl is a package for defining and using spectral models, with a number of utilities to make model composition easy and invocation fast. SpectralFitting wraps LibXSPEC_jll.jl to expose the library of models from HEASoft XSPEC, and provides helper functions for operating with spectral data from a number of different missions. The package natively uses LsqFit.jl to fit parameters using the Levenberg-Marquardt algorithm, but makes it easy to use Optim.jl for more specialized fitting algorithms, or Turing.jl for Bayesian inference and MCMC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpectralFitting is designed to be extended, such that new models are simple to create, and new dataset processing pipelines for different missions are brief to define. Where performance is key, SpectralFitting helps you define fast and AD-compatible surrogates of spectral models using Surrogates.jl, and embed them in the model composition algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, install LibXSPEC_jll and SpectralFitting:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/astro-group-bristol/LibXSPEC_jll.jl\")\nPkg.add(url = \"https://github.com/fjebaker/SpectralFitting.jl\")\n\nusing SpectralFitting\n# ....","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more University of Bristol Astrophysics Group codes, see our GitHub organisation.","category":"page"}]
}
