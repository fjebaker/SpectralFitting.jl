<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Why &amp; How · SpectralFitting.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SpectralFitting.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpectralFitting.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Why &amp; How</a><ul class="internal"><li><a class="tocitem" href="#Rewriting-model-calls-during-invocation"><span>Rewriting model calls during invocation</span></a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../using-models/">Using models</a></li><li><a class="tocitem" href="../models/">Model index</a></li><li><a class="tocitem" href="../composite-models/">Composite models</a></li><li><a class="tocitem" href="../surrogate-models/">Surrogate models</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Why &amp; How</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Why &amp; How</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fjebaker/SpectralFitting.jl/blob/main/docs/src/why-and-how.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Why-and-how"><a class="docs-heading-anchor" href="#Why-and-how">Why &amp; how</a><a id="Why-and-how-1"></a><a class="docs-heading-anchor-permalink" href="#Why-and-how" title="Permalink"></a></h1><p>SpectralFitting.jl is a package for fitting models to spectral data, similar to <a href="https://heasarc.gsfc.nasa.gov/xanadu/xspec/">XSPEC</a>, <a href="https://sherpa.readthedocs.io/en/latest/ciao.html">Sherpa</a> or <a href="https://space.mit.edu/CXC/isis/">ISIS</a>.</p><p>The rationale for this package is to provide a unanimous interface for different model libraries, and to leverage the bleeding edge advancements in computing that are available in Julia, including the rich statistics ecosystem, with <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic-differentiation</a> and <a href="https://julialang.org/benchmarks/"><em>speed</em></a>.</p><p>SpectralFitting aims to provide highly optimised and flexible fitting algorithms, along with a library of spectral models, for use in any field of Astronomy that concerns itself with spectral data.</p><h2 id="Rewriting-model-calls-during-invocation"><a class="docs-heading-anchor" href="#Rewriting-model-calls-during-invocation">Rewriting model calls during invocation</a><a id="Rewriting-model-calls-during-invocation-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-model-calls-during-invocation" title="Permalink"></a></h2><p>SpectralFitting.jl tries to optimise model invocation through source-rewriting. For compatibility with the XSPEC model library, this is achieved through aggressive pre-allocation and shuffling of output vectors. All XSPEC models output the result of their calculation through side effects into a flux array passed as an argument, and therefore each model invocation requires its own output before addition or multiplication of fluxes may occur.</p><p>Principally, combining several models together would look like this:</p><pre><code class="language-julia hljs">energy = collect(range(0.1, 20.0, 100))

flux1 = invokemodel(energy, XS_PowerLaw())
flux2 = invokemodel(energy, XS_PowerLaw(a=FitParam(3.0)))
flux3 = invokemodel(energy, XS_BlackBody())
flux4 = invokemodel(energy, XS_PhotoelectricAbsorption())

total_flux = @. flux4 * (flux1 + flux2 + flux3)
sum(total_flux)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12.049105492578438</code></pre><p>But these operations could also be performed in a different order:</p><pre><code class="language-julia hljs">flux1 = invokemodel(energy, XS_PowerLaw())
flux2 = invokemodel(energy, XS_PowerLaw(a=FitParam(3.0)))
total_flux = @. flux1 + flux2

flux3 = invokemodel(energy, XS_BlackBody())
@. total_flux = total_flux + flux3

flux4 = invokemodel(energy, XS_PhotoelectricAbsorption())
@. total_flux = total_flux * flux4
sum(total_flux)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12.049105492578438</code></pre><p>Doing so would allow us to only pre-allocate 2 flux arrays, instead of 4 when using the in-place variants:</p><pre><code class="language-julia hljs">flux1, flux2 = make_fluxes(energy, 2)

invokemodel!(flux1, energy, XS_PowerLaw())
invokemodel!(flux2, energy, XS_PowerLaw(a=FitParam(3.0)))
@. flux1 = flux1 + flux2

invokemodel!(flux2, energy, XS_BlackBody())
@. flux1 = flux1 + flux2

invokemodel!(flux2, energy, XS_PhotoelectricAbsorption())
@. flux1 = flux1 * flux2
sum(flux1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12.049105492578438</code></pre><p>It is precisely this re-writing that SpectralFitting performs via <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Generated-functions"><code>@generated</code></a> functions. We can inspect the code used to generate the invocation body after defining a <a href="../composite-models/#SpectralFitting.CompositeModel"><code>CompositeModel</code></a>:</p><pre><code class="language-julia hljs">fluxes = (flux1, flux2)

model = XS_PhotoelectricAbsorption() * (
    XS_PowerLaw() + XS_PowerLaw(a=FitParam(3.0)) + XS_BlackBody()
)

params = get_value.(get_params(model))

SpectralFitting.__generated_model_call!(fluxes, energy, typeof(model), params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">begin
    @inbounds let (flux1, flux2) = fluxes
        var"##K#356" = params[1]
        var"##a#357" = params[2]
        var"##K#358" = params[3]
        var"##a#359" = params[4]
        var"##K#360" = params[5]
        var"##T#361" = params[6]
        var"##ηH#362" = params[7]
        invokemodel!(flux1, energy, XS_PowerLaw, var"##K#356", var"##a#357")
        invokemodel!(flux2, energy, XS_PowerLaw, var"##K#358", var"##a#359")
        @. flux1 = flux1 + flux2
        invokemodel!(flux2, energy, XS_BlackBody, var"##K#360", var"##T#361")
        @. flux1 = flux1 + flux2
        invokemodel!(flux2, energy, XS_PhotoelectricAbsorption, var"##ηH#362")
        @. flux1 = flux1 * flux2
        return flux1
    end
end
</code><button class="copy-button fas fa-copy"></button></pre><p>This generated function also takes care of some other things for us, such as unpacking parameters (optionally unpacking frozen parameters separately), and ensuring any closure are passed to <a href="../using-models/#SpectralFitting.invokemodel"><code>invokemodel</code></a> if a model needs them (e.g., <a href="../surrogate-models/#SpectralFitting.SurrogateSpectralModel"><code>SurrogateSpectralModel</code></a>).</p><p>This is achieved by moving as much information as possible about the model and its construction to its type, such that all of the invocation and parameter unpacking may be inferred at compile time.</p><p>Naturally, the <a href="../composite-models/#SpectralFitting.CompositeModel"><code>CompositeModel</code></a> types also support the out-of-place <a href="../using-models/#SpectralFitting.invokemodel"><code>invokemodel</code></a> and will allocate the minimum number of flux arrays needed, inferred using <a href="../using-models/#SpectralFitting.flux_count"><code>flux_count</code></a>:</p><pre><code class="language-julia hljs">flux = invokemodel(energy, model)
sum(flux)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12.049105492578438</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>With the addition of more pure-Julia models, non-allocating methods without aggressive pre-allocation are possible, and will be added in the future. Such methods may allow models to add or multiply in-place on the total flux array, instead of relying on later broadcasts.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../using-models/">Using models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Monday 22 August 2022 16:07">Monday 22 August 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
